"use client"

// src/components/forward-ref.ts
import * as React from "react";
function forwardRef2(render) {
  return React.forwardRef(
    render
  );
}

// src/components/memo.ts
import * as React2 from "react";
function memo2(Component, propsAreEqual) {
  return React2.memo(Component, propsAreEqual);
}

// src/pseudos.ts
var toGroup = (selectors) => ["[role=group]", "[data-group]", ".group"].map((prefix) => merge(parse(selectors), prefix, " &")).join(", ");
var toPeer = (selectors) => ["[data-peer]", ".peer"].map((prefix) => merge(parse(selectors), prefix, " ~ &")).join(", ");
var parse = (selectors) => selectors.split(",").map((selector) => selector.trim().slice(1));
var merge = (selectors, prefix = "&", suffix = "") => selectors.map((selector) => `${prefix}${selector}${suffix}`).join(", ");
var attributes = {
  /**
   * The CSS `[data-accept]` attribute selector.
   */
  _accept: "&[data-accept]",
  /**
   * The CSS `[data-between]` attribute selector.
   */
  _between: "&[data-between]",
  /**
   * The CSS `[data-end]` attribute selector.
   */
  _end: "&[data-end]",
  /**
   * The CSS `[aria-selected=true]` attribute selector.
   *
   * - `[aria-expanded=true]`
   * - `[data-expanded]`
   */
  _expanded: "&[data-expanded], &[aria-expanded=true]",
  /**
   * The CSS `[data-filled]` attribute selector.
   */
  _filled: "&[data-filled]",
  /**
   * The CSS `[data-grabbed]` attribute selector.
   *
   * - `[data-grabbed]`
   * - `[aria-grabbed=true]`
   */
  _grabbed: "&[data-grabbed], &[aria-grabbed=true]",
  /**
   * The CSS `[hidden]` attribute selector.
   *
   * - `[hidden]`
   * - `[data-hidden]`
   */
  _hidden: "&[hidden], &[data-hidden]",
  /**
   * The CSS `[data-holiday]` attribute selector.
   */
  _holiday: "&[data-holiday]",
  /**
   * The CSS `[data-idle]` attribute selector.
   */
  _idle: "&[data-idle]",
  /**
   * The CSS `[data-loaded]` attribute selector.
   */
  _loaded: "&[data-loaded]",
  /**
   * The CSS `[aria-busy=true]` attribute selector.
   *
   * - `[data-loading]`
   * - `[aria-busy=true]`
   */
  _loading: "&[data-loading], &[aria-busy=true]",
  /**
   * The CSS `[hidden]` attribute selector.
   */
  _nativeHidden: "&[hidden]",
  /**
   * The CSS `[data-not-allowed]` attribute selector.
   *
   * - `[data-not-allowed]`
   */
  _notAllowed: "&[data-not-allowed]",
  /**
   * The CSS `:where([data-outside])` attribute selector.
   */
  _outside: "&:where([data-outside])",
  /**
   * The CSS `[data-pressed]` attribute selector.
   *
   * - `[data-pressed]`
   * - `[aria-pressed=true]`
   */
  _pressed: "&[data-pressed], &[aria-pressed=true]",
  /**
   * The CSS `[data-reject]` attribute selector.
   */
  _reject: "&[data-reject]",
  _ripple: "& .ui-ripple",
  /**
   * The CSS `:selected` attribute selector.
   *
   * - `[data-selected]`
   * - `[aria-selected=true]`
   */
  _selected: "&[data-selected], &[aria-selected=true]",
  /**
   * The CSS `[data-start]` attribute selector.
   */
  _start: "&[data-start]",
  /**
   * The CSS `[data-today]` attribute selector.
   */
  _today: "&[data-today]",
  /**
   * The CSS `:where([data-weekend])` attribute selector.
   */
  _weekend: "&:where([data-weekend])"
};
var attributeProperties = Object.keys(
  attributes
);
var attributeSelectors = Object.values(attributes);
var pseudoElements = {
  /**
   * The CSS `::after` pseudo-element.
   */
  _after: "&::after",
  /**
   * The CSS `::backdrop` pseudo-element.
   */
  _backdrop: "&::backdrop",
  /**
   * The CSS `::before` pseudo-element.
   */
  _before: "&::before",
  /**
   * The CSS `::cue` pseudo-element.
   */
  _cue: "&::cue",
  /**
   * The CSS `::cue-region` pseudo-element.
   */
  _cueRegion: "&::cue-region",
  /**
   * The CSS `::file-selector-button` pseudo-element.
   */
  _fileSelector: "&::file-selector-button",
  /**
   * The CSS `::first-letter` pseudo-element.
   */
  _firstLetter: "&::first-letter",
  /**
   * The CSS `::first-line` pseudo-element.
   */
  _firstLine: "&::first-line",
  /**
   * The CSS `::marker` pseudo-element.
   */
  _marker: "&::marker",
  /**
   * The CSS `::placeholder` pseudo-element.
   *
   * - `::placeholder`
   * - `[data-placeholder]`
   */
  _placeholder: "&::placeholder, &[data-placeholder]",
  /**
   * The CSS `::-webkit-scrollbar` pseudo-element.
   *
   * - `::-webkit-scrollbar`
   * - `[data-scrollbar]`
   */
  _scrollbar: "&::-webkit-scrollbar, &[data-scrollbar]",
  /**
   * The CSS `::-webkit-scrollbar-button` pseudo-element.
   */
  _scrollbarButton: "&::-webkit-scrollbar-button",
  /**
   * The CSS `::-webkit-scrollbar-corner` pseudo-element.
   */
  _scrollbarCorner: "&::-webkit-scrollbar-corner",
  /**
   * The CSS `::-webkit-scrollbar-thumb` pseudo-element.
   */
  _scrollbarThumb: "&::-webkit-scrollbar-thumb",
  /**
   * The CSS `::-webkit-scrollbar-track` pseudo-element.
   */
  _scrollbarTrack: "&::-webkit-scrollbar-track",
  /**
   * The CSS `::-webkit-scrollbar-track-piece` pseudo-element.
   */
  _scrollbarTrackPiece: "&::-webkit-scrollbar-track-piece",
  /**
   * The CSS `::selection` pseudo-element.
   */
  _selection: "&::selection"
};
var pseudoElementProperties = Object.keys(
  pseudoElements
);
var pseudoElementSelectors = Object.values(pseudoElements);
var pseudoClasses = {
  /**
   * The CSS `:active` pseudo-class.
   *
   * - `:active`
   * - `[data-active]`
   */
  _active: "&:active, &[data-active]",
  /**
   * The CSS `:any-link` pseudo-class.
   *
   * - `:any-link`
   * - `[data-any-link]`
   */
  _anyLink: "&:any-link, &[data-any-link]",
  /**
   * The CSS `:autofill` pseudo-class.
   */
  _autofill: "&:autofill, &:-webkit-autofill",
  /**
   * The CSS `:blank` pseudo-class.
   *
   * - `:blank`
   * - `[data-blank]`
   */
  _blank: "&:blank, &[data-blank]",
  /**
   * The CSS `:checked` pseudo-class.
   *
   * - `:checked`
   * - `[data-checked]`
   * - `[aria-checked=true]`
   */
  _checked: "&:checked, &[data-checked], &[aria-checked=true]",
  /**
   * The CSS `:default` pseudo-class.
   */
  _default: "&:default",
  /**
   * The CSS `:disabled` pseudo-class.
   *
   * - `:disabled`
   * - `[disabled]`
   * - `[aria-disabled=true]`
   * - `[data-disabled]`
   */
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  /**
   * The CSS `:empty` pseudo-class.
   */
  _empty: "&:empty",
  /**
   * The CSS `:enabled` pseudo-class.
   */
  _enabled: "&:enabled, &[data-enabled]",
  /**
   * The CSS `:nth-of-type(even)` pseudo-class.
   */
  _even: "&:nth-of-type(even)",
  /**
   * The CSS `:first-of-type` pseudo-class.
   */
  _first: "&:first-of-type",
  /**
   * The CSS `:focus` pseudo-class.
   *
   * - `:focus`
   * - `[data-focus]`
   */
  _focus: "&:focus, &[data-focus]",
  /**
   * The CSS `:focus-visible` pseudo-class.
   *
   * - `:focus-visible`
   * - `[data-focus-visible]`
   */
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  /**
   * The CSS `:focus-within` pseudo-class.
   *
   * - `:focus-within`
   * - `[data-focus-within]`
   */
  _focusWithin: "&:focus-within, &[data-focus-within]",
  /**
   * The CSS `:fullscreen` pseudo-class.
   */
  _fullScreen: "&:fullscreen",
  /**
   * The CSS `:horizontal` pseudo-class.
   *
   * - `:horizontal`
   * - `[aria-orientation=horizontal]`
   * - `[data-orientation=horizontal]`
   */
  _horizontal: "&:horizontal, &[data-orientation=horizontal], &[aria-orientation=horizontal]",
  /**
   * The CSS `:hover` pseudo-class.
   *
   * - `:hover`
   * - `[data-hover]`
   */
  _hover: "&:hover, &[data-hover]",
  /**
   * The CSS `:indeterminate` pseudo-class.
   *
   * - `:indeterminate`
   * - `[aria-checked=mixed]`
   * - `[data-indeterminate]`
   */
  _indeterminate: "&:indeterminate, &[data-indeterminate], &[aria-checked=mixed]",
  /**
   * The CSS `:in-range` pseudo-class.
   *
   * - `:in-range`
   * - `[data-in-range]`
   */
  _inRange: "&:in-range, &[data-in-range]",
  /**
   * The CSS `:invalid` attribute selector.
   *
   * - `[data-invalid]`
   * - `[aria-invalid=true]`
   */
  _invalid: "&[data-invalid], &[aria-invalid=true]",
  /**
   * The CSS `:last-of-type` pseudo-class.
   */
  _last: "&:last-of-type",
  /**
   * The CSS `:link` pseudo-class.
   *
   * - `:link`
   * - `[data-link]`
   */
  _link: "&:link, &[data-link]",
  /**
   * The CSS `:modal` pseudo-class.
   */
  _modal: "&:modal",
  /**
   * The CSS `:active` pseudo-class.
   */
  _nativeActive: "&:active",
  /**
   * The CSS `:checked` pseudo-class.
   */
  _nativeChecked: "&:checked",
  /**
   * The CSS `:disabled` pseudo-class.
   *
   * - `:disabled`
   * - `[disabled]`
   */
  _nativeDisabled: "&:disabled, &[disabled]",
  /**
   * The CSS `:focus` pseudo-class.
   */
  _nativeFocus: "&:focus",
  /**
   * The CSS `:focus-visible` pseudo-class.
   */
  _nativeFocusVisible: "&:focus-visible",
  /**
   * The CSS `:focus-within` pseudo-class.
   */
  _nativeFocusWithin: "&:focus-within",
  /**
   * The CSS `:hover` pseudo-class.
   */
  _nativeHover: "&:hover",
  /**
   * The CSS `:read-only` pseudo-class.
   *
   * - `[readonly]`
   * - `[aria-readonly=true]`
   */
  _nativeReadOnly: "&[readonly], &[aria-readonly=true]",
  /**
   * The CSS `:target` pseudo-class.
   */
  _nativeTarget: "&:target",
  /**
   * The CSS `:valid` pseudo-class.
   */
  _nativeValid: "&:valid",
  /**
   * The CSS `:not(:first-of-type)` pseudo-class.
   */
  _notFirst: "&:not(:first-of-type)",
  /**
   * The CSS `:not(:last-of-type)` pseudo-class.
   */
  _notLast: "&:not(:last-of-type)",
  /**
   * The CSS `:not(:target)` pseudo-class.
   */
  _notTarget: "&:not(:target)",
  /**
   * The CSS `:nth-of-type(odd)` pseudo-class.
   */
  _odd: "&:nth-of-type(odd)",
  /**
   * The CSS `:only-of-type` pseudo-class.
   */
  _only: "&:only-of-type",
  /**
   * The CSS `:optional` pseudo-class.
   *
   * - `:optional`
   * - `[data-optional]`
   */
  _optional: "&:optional, &[data-optional]",
  /**
   * The CSS `:out-of-range` pseudo-class.
   *
   * - `:out-of-range`
   * - `[data-out-of-range]`
   */
  _outRange: "&:out-of-range, &[data-out-of-range]",
  /**
   * The CSS `:paused` pseudo-class.
   *
   * - `:paused`
   * - `[data-paused]`
   */
  _paused: "&:paused, &[data-paused]",
  /**
   * The CSS `:picture-in-picture` pseudo-class.
   */
  _picture: "&:picture-in-picture",
  /**
   * The CSS `:placeholder-shown` pseudo-class.
   */
  _placeholderShown: "&:placeholder-shown",
  /**
   * The CSS `:playing` pseudo-class.
   *
   * - `:playing`
   * - `[data-playing]`
   */
  _playing: "&:playing, &[data-playing]",
  /**
   * The CSS `:read-only` pseudo-class.
   *
   * - `[readonly]`
   * - `[aria-readonly=true]`
   * - `[data-readonly]`
   */
  _readOnly: "&[readonly], &[data-readonly], &[aria-readonly=true]",
  /**
   * The CSS `:read-write` pseudo-class.
   *
   * - `:read-write`
   * - `[data-read-write]`
   */
  _readWrite: "&:read-write, &[data-read-write]",
  /**
   * The CSS `:required` pseudo-class.
   *
   * - `:required`
   * - `[required]`
   */
  _required: "&:required, &[required]",
  /**
   * The CSS `:target` pseudo-class.
   *
   * - `:target`
   * - `[data-target]`
   */
  _target: "&:target, &[data-target]",
  /**
   * The CSS `:user-invalid` pseudo-class.
   *
   * - `:user-invalid`
   * - `[data-user-invalid]`
   */
  _userInvalid: "&:user-invalid, &[data-user-invalid]",
  /**
   * The CSS `:valid` pseudo-class.
   *
   * - `:valid`
   * - `[data-valid]`
   */
  _valid: "&:valid, &[data-valid]",
  /**
   * The CSS `:vertical` pseudo-class.
   *
   * - `:vertical`
   * - `[aria-orientation=vertical]`
   * - `[data-orientation=vertical]`
   */
  _vertical: "&:vertical, &[data-orientation=vertical], &[aria-orientation=vertical]",
  /**
   * The CSS `:visited` pseudo-class.
   */
  _visited: "&:visited"
};
var pseudoClassProperties = Object.keys(
  pseudoClasses
);
var pseudoClassSelectors = Object.values(pseudoClasses);
var atRules = {
  /**
   * Styles for when `data-mode` is applied to any parent of this component or element.
   */
  _dark: ".ui-dark &:not([data-mode]), [data-mode=dark] &:not([data-mode]), &[data-mode=dark]",
  /**
   * The CSS `@media (orientation: landscape)` media query.
   */
  _landscape: "@media (orientation: landscape)",
  /**
   * Styles for when `data-mode` is applied to any parent of this component or element.
   */
  _light: ".ui-light &:not([data-mode]), [data-mode=light] &:not([data-mode]), &[data-mode=light]",
  /**
   * The CSS `@media (prefers-color-scheme: dark)` media query.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",
  /**
   * The CSS `@media (prefers-color-scheme: light)` media query.
   */
  _mediaLight: "@media (prefers-color-scheme: light)",
  /**
   * The CSS `@media (prefers-reduced-motion: reduce)` media query.
   */
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  /**
   * The CSS `@media (orientation: portrait)` media query.
   */
  _portrait: "@media (orientation: portrait)",
  /**
   * The CSS `@media print` media query.
   */
  _print: "@media print"
};
var atRuleProperties = Object.keys(atRules);
var atRuleSelectors = Object.values(atRules);
var groupAttributes = {
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is accepted.
   */
  _groupAccept: toGroup(attributes._accept),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is active.
   */
  _groupActive: toGroup(pseudoClasses._active),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is blank.
   */
  _groupBlank: toGroup(pseudoClasses._blank),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is checked.
   */
  _groupChecked: toGroup(pseudoClasses._checked),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is disabled.
   */
  _groupDisabled: toGroup(pseudoClasses._disabled),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is enabled.
   */
  _groupEnabled: toGroup(pseudoClasses._enabled),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is expanded.
   */
  _groupExpanded: toGroup(attributes._expanded),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is focused.
   */
  _groupFocus: toGroup(pseudoClasses._focus),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is focused-visible.
   */
  _groupFocusVisible: toGroup(pseudoClasses._focusVisible),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is focus-within.
   */
  _groupFocusWithin: toGroup(pseudoClasses._focusWithin),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is grabbed.
   */
  _groupGrabbed: toGroup(attributes._grabbed),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is horizontal.
   */
  _groupHorizontal: toGroup(pseudoClasses._horizontal),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is hovered.
   */
  _groupHover: toGroup(pseudoClasses._hover),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is idle.
   */
  _groupIdle: toGroup(attributes._idle),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is invalid.
   */
  _groupInvalid: toGroup(pseudoClasses._invalid),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is loaded.
   */
  _groupLoaded: toGroup(attributes._loaded),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is loading.
   */
  _groupLoading: toGroup(attributes._loading),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is optional.
   */
  _groupOptional: toGroup(pseudoClasses._optional),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` has a placeholder shown.
   */
  _groupPlaceholderShown: toGroup(pseudoClasses._placeholderShown),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is pressed.
   */
  _groupPressed: toGroup(attributes._pressed),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is read-only.
   */
  _groupReadOnly: toGroup(pseudoClasses._readOnly),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is read-write.
   */
  _groupReadWrite: toGroup(pseudoClasses._readWrite),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is rejected.
   */
  _groupReject: toGroup(attributes._reject),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is required.
   */
  _groupRequired: toGroup(pseudoClasses._required),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is selected.
   */
  _groupSelected: toGroup(attributes._selected),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is user-invalid.
   */
  _groupUserInvalid: toGroup(pseudoClasses._userInvalid),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is valid.
   */
  _groupValid: toGroup(pseudoClasses._valid),
  /**
   * Styles to apply when a parent element with `role=group`, `data-group` or `.group` is vertical.
   */
  _groupVertical: toGroup(pseudoClasses._vertical)
};
var groupAttributeProperties = Object.keys(
  groupAttributes
);
var groupAttributeSelectors = Object.values(groupAttributes);
var peerAttributes = {
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is accepted.
   */
  _peerAccept: toPeer(attributes._accept),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is active.
   */
  _peerActive: toPeer(pseudoClasses._active),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is blank.
   */
  _peerBlank: toPeer(pseudoClasses._blank),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is checked.
   */
  _peerChecked: toPeer(pseudoClasses._checked),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is disabled.
   */
  _peerDisabled: toPeer(pseudoClasses._disabled),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is enabled.
   */
  _peerEnabled: toPeer(pseudoClasses._enabled),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is expanded.
   */
  _peerExpanded: toPeer(attributes._expanded),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is focused.
   */
  _peerFocus: toPeer(pseudoClasses._focus),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is focused-visible.
   */
  _peerFocusVisible: toPeer(pseudoClasses._focusVisible),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is focus-within.
   */
  _peerFocusWithin: toPeer(pseudoClasses._focusWithin),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is grabbed.
   */
  _peerGrabbed: toPeer(attributes._grabbed),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is horizontal.
   */
  _peerHorizontal: toPeer(pseudoClasses._horizontal),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is hovered.
   */
  _peerHover: toPeer(pseudoClasses._hover),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is idle.
   */
  _peerIdle: toPeer(attributes._idle),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is invalid.
   */
  _peerInvalid: toPeer(pseudoClasses._invalid),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is loaded.
   */
  _peerLoaded: toPeer(attributes._loaded),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is loading.
   */
  _peerLoading: toPeer(attributes._loading),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is optional.
   */
  _peerOptional: toPeer(pseudoClasses._optional),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` has a placeholder shown.
   */
  _peerPlaceholderShown: toPeer(pseudoClasses._placeholderShown),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is pressed.
   */
  _peerPressed: toPeer(attributes._pressed),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is read-only.
   */
  _peerReadOnly: toPeer(pseudoClasses._readOnly),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is read-write.
   */
  _peerReadWrite: toPeer(pseudoClasses._readWrite),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is rejected.
   */
  _peerReject: toPeer(attributes._reject),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is required.
   */
  _peerRequired: toPeer(pseudoClasses._required),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is selected.
   */
  _peerSelected: toPeer(attributes._selected),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is user-invalid.
   */
  _peerUserInvalid: toPeer(pseudoClasses._userInvalid),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is valid.
   */
  _peerValid: toPeer(pseudoClasses._valid),
  /**
   * Styles to apply when a parent element with `data-peer` or `.peer` is vertical.
   */
  _peerVertical: toPeer(pseudoClasses._vertical)
};
var peerAttributeProperties = Object.keys(
  peerAttributes
);
var peerAttributeSelectors = Object.values(peerAttributes);
var pseudos = {
  ...pseudoElements,
  ...attributes,
  ...pseudoClasses,
  ...atRules,
  ...groupAttributes,
  ...peerAttributes
};
var pseudoProperties = Object.keys(pseudos);
var pseudoSelectors = Object.values(pseudos);

// src/config/index.ts
import { isNumber, isObject as isObject4 } from "@yamada-ui/utils";

// src/config/animation.ts
import { keyframes as emotionKeyframes2 } from "@emotion/react";
import { StyleSheet } from "@emotion/sheet";
import { createdDom, isObject as isObject2 } from "@yamada-ui/utils";

// src/config/utils.ts
import { keyframes as emotionKeyframes } from "@emotion/react";
import { isObject, isString, isUndefined } from "@yamada-ui/utils";
var globalValues = /* @__PURE__ */ new Set([
  "-moz-initial",
  "inherit",
  "initial",
  "none",
  "revert",
  "unset"
]);
function isCSSFunction(value) {
  return isString(value) && value.includes("(") && value.includes(")");
}
function getCSSFunction(value) {
  var _a;
  const regex = /(^[a-z-A-Z]+)\((.*)\)/g;
  const [, type, values] = (_a = regex.exec(value)) != null ? _a : [];
  return { type, values };
}
function splitValues(values, cb = (current) => current === ",", addSeparator = false) {
  const result = [];
  let value = "";
  let depth = 0;
  for (let i = 0; i < values.length; i++) {
    const current = values[i];
    const prev = values[i - 1];
    const next = values[i + 1];
    if (current === "(") depth++;
    if (current === ")") depth--;
    if (!isUndefined(current) && cb(current, prev, next) && depth === 0) {
      if (value) result.push(value.trim());
      if (addSeparator) result.push(current);
      value = "";
    } else {
      value += current;
    }
  }
  if (value) result.push(value.trim());
  return result.filter(Boolean);
}
function isCSSVar(value) {
  return /^var\(--.+\)$/.test(value);
}
function analyzeCSSValue(value) {
  let n = parseFloat(value.toString());
  const unit = value.toString().replace(String(n), "");
  return { isUnitless: !unit, unit, value };
}
function tokenToVar(token, value) {
  return function(theme) {
    var _a;
    const match = isString(value) ? value.match(/fallback\(([^,)]+),?\s*([^]+)?\)/) : null;
    const [, resolvedValue, fallbackValue] = match != null ? match : [];
    if (resolvedValue) value = resolvedValue;
    const resolvedToken = `${token}.${value}`;
    if (isObject(theme.__cssMap) && resolvedToken in theme.__cssMap) {
      return (_a = theme.__cssMap[resolvedToken]) == null ? void 0 : _a.ref;
    } else {
      return fallbackValue != null ? fallbackValue : value;
    }
  };
}
function mode(light, dark) {
  return function(colorMode = "light") {
    return colorMode === "light" ? light : dark;
  };
}
function keyframes(...arg) {
  return emotionKeyframes(...arg);
}
function combineFunctions(a, b) {
  return function(value, ...args) {
    return b(a(value, ...args), ...args);
  };
}
function pipe(...transformers) {
  return transformers.reduce(combineFunctions);
}

// src/config/animation.ts
var styleSheet = createdDom() ? new StyleSheet({ key: "css", container: document.head }) : void 0;
function transformAnimationValue(value) {
  return Object.entries(value).reduce((prev, [key, value2]) => {
    if (key === "duration") {
      prev.animationDuration = value2;
    } else if (key === "timingFunction") {
      prev.animationTimingFunction = value2;
    } else {
      prev[key] = value2;
    }
    return prev;
  }, {});
}
function animation(value, theme, css2, _prev) {
  if (value == null || globalValues.has(value)) return value;
  if (isObject2(value)) {
    const {
      animationDuration = "0s",
      animationTimingFunction = "ease",
      delay = "0s",
      direction = "normal",
      fillMode = "none",
      iterationCount = "1",
      keyframes: keyframes2,
      playState = "running"
    } = css2(transformAnimationValue(value))(theme);
    const { name, styles: styles2 } = emotionKeyframes2(keyframes2);
    styleSheet == null ? void 0 : styleSheet.insert(styles2);
    return `${name} ${animationDuration} ${animationTimingFunction} ${delay} ${iterationCount} ${direction} ${fillMode} ${playState}`;
  } else if (value.includes(",")) {
    value = value.split(",").map((value2) => {
      value2 = value2.trim();
      value2 = tokenToVar("animations", value2)(theme);
      return value2;
    }).join(",");
    return value;
  } else {
    value = tokenToVar("animations", value)(theme);
    return value;
  }
}

// src/config/at-rule.ts
import { filterUndefined, isArray, toKebabCase } from "@yamada-ui/utils";
var generateAtRule = (identifier) => (values, theme) => {
  if (!isArray(values)) return values;
  return values.reduce(
    (prev, {
      type,
      name,
      css: css2,
      h,
      height,
      maxH,
      maxHeight,
      maxW,
      maxWidth,
      minH,
      minHeight,
      minW,
      minWidth,
      query,
      w,
      width,
      ...rest
    }) => {
      var _a;
      width != null ? width : width = w;
      minWidth != null ? minWidth : minWidth = minW;
      maxWidth != null ? maxWidth : maxWidth = maxW;
      height != null ? height : height = h;
      minHeight != null ? minHeight : minHeight = minH;
      maxHeight != null ? maxHeight : maxHeight = maxH;
      if (!query) {
        const resolvedRest = filterUndefined({
          height,
          maxHeight,
          maxWidth,
          minHeight,
          minWidth,
          width,
          ...rest
        });
        query = Object.entries(resolvedRest).map(([key, value]) => {
          value = tokenToVar("sizes", value)(theme);
          return `(${toKebabCase(key)}: ${value})`;
        }).join(" and ");
      }
      const condition = `@${identifier} ${(_a = type != null ? type : name) != null ? _a : ""} ${query}`;
      prev[condition] = css2;
      return prev;
    },
    {}
  );
};

// src/config/calc.ts
import { isNumeric } from "@yamada-ui/utils";
var OPERATORS = ["+", "-", "*", "/"];
function getValue(value, fallbackValue = "") {
  return function(token, theme, ...rest) {
    var _a;
    if (!value) return fallbackValue;
    const prevent = isCSSFunction(value);
    if (prevent) {
      return generateCalc(token)(value, theme, ...rest);
    } else {
      if (isNumeric(value)) return value;
      const resolvedToken = `${token}.${value}`;
      return theme.__cssMap && resolvedToken in theme.__cssMap ? (_a = theme.__cssMap[resolvedToken]) == null ? void 0 : _a.ref : value;
    }
  };
}
function isOperator(value) {
  return new RegExp(`\\s[${OPERATORS.join("\\")}]\\s`).test(value);
}
function generateCalc(token) {
  return function(value, theme, ...rest) {
    if (value == null || globalValues.has(value)) return value;
    const prevent = isCSSFunction(value);
    if (!prevent) return value;
    let { type, values } = getCSSFunction(value);
    if (!type || !values) return value;
    switch (type) {
      case "calc": {
        const computedValues = splitValues(
          values,
          (char, prev, next) => isOperator(`${prev}${char}${next}`),
          true
        ).map((value2) => {
          if (value2 && OPERATORS.includes(value2)) return value2;
          return getValue(value2)(token, theme, ...rest);
        });
        return `calc(${computedValues.join(" ")})`;
      }
      case "min":
      case "max": {
        let [firstValue, secondValue, ...otherValues] = splitValues(values);
        firstValue = getValue(firstValue, "100%")(token, theme, ...rest);
        secondValue = getValue(secondValue, "100%")(token, theme, ...rest);
        otherValues = otherValues.map(
          (value2) => getValue(value2)(token, theme, ...rest)
        );
        return `${type}(${firstValue}, ${secondValue}` + (otherValues.length ? `, ${otherValues.join(", ")}` : "") + ")";
      }
      case "clamp": {
        let [min, preferred, max] = splitValues(values);
        if (!max) {
          max = preferred;
          preferred = "";
        }
        min = getValue(min)(token, theme, ...rest);
        preferred = getValue(preferred, "100%")(token, theme, ...rest);
        max = getValue(max)(token, theme, ...rest);
        return `clamp(${min}, ${preferred}, ${max})`;
      }
      case "minmax": {
        let [min, max] = splitValues(values);
        min = getValue(min)(token, theme, ...rest);
        max = getValue(max)(token, theme, ...rest);
        return `minmax(${min}, ${max})`;
      }
      case "fit-content": {
        let [value2] = splitValues(values);
        value2 = getValue(value2)(token, theme, ...rest);
        return `fit-content(${value2})`;
      }
      default:
        return value;
    }
  };
}

// src/config/color-mix.ts
var DEFAULT_METHOD = "in srgb";
var methods = {
  "a98-rgb": "in a98-rgb",
  "display-p3": "in display-p3",
  lab: "in lab",
  oklab: "in oklab",
  "prophoto-rgb": "in prophoto-rgb",
  rec2020: "in rec2020",
  srgb: "in srgb",
  "srgb-linear": "in srgb-linear",
  xyz: "in xyz",
  "xyz-d50": "in xyz-d50",
  "xyz-d65": "in xyz-d65"
};
function getColor(value, theme) {
  var _a;
  if (!value) return "";
  let [color, percent, ...rest] = value.split(" ").filter(Boolean);
  if (rest.length) return value;
  const token = `colors.${color}`;
  color = theme.__cssMap && token in theme.__cssMap ? (_a = theme.__cssMap[token]) == null ? void 0 : _a.ref : color;
  if (percent && !percent.endsWith("%")) percent = `${percent}%`;
  return !percent ? color : `${color} ${percent}`;
}
function colorMix(value, theme, _css, _prev) {
  if (value == null || globalValues.has(value)) return value;
  const prevent = isCSSFunction(value);
  if (!prevent) return value;
  const { type, values } = getCSSFunction(value);
  if (!values) return value;
  switch (type) {
    case "mix":
    case "color-mix": {
      let [color2, color1, method] = splitValues(values).reverse();
      if (method) {
        method = method in methods ? methods[method] : method;
      } else {
        method = DEFAULT_METHOD;
      }
      color1 = getColor(color1, theme);
      color2 = getColor(color2, theme);
      return `color-mix(${method}` + (color1 ? `, ${color1}` : "") + (color2 ? `, ${color2}` : "") + ")";
    }
    case "tint":
    case "shade":
    case "transparentize": {
      const [color, percent] = splitValues(values);
      const color1 = getColor(`${color} ${percent}`, theme);
      const color2 = type === "transparentize" ? "transparent" : type === "tint" ? "#fff" : "#000";
      return `color-mix(${DEFAULT_METHOD}, ${color1}, ${color2})`;
    }
    case "tone": {
      const [color, tone] = splitValues(values);
      const color1 = getColor(color, theme);
      if (!tone) return color1;
      let ratio = parseInt(tone) || 500;
      if (ratio < 50 && 950 < ratio) ratio = 500;
      if (ratio === 500) return color1;
      const color2 = ratio < 500 ? "#fff" : "#000";
      const percent = `${100 - Math.abs(ratio - 500) * 2 / 10}%`;
      return `color-mix(${DEFAULT_METHOD}, ${color1} ${percent}, ${color2})`;
    }
    default:
      return value;
  }
}

// src/config/filter.ts
function generateFilter(type = "filter") {
  return function(value) {
    if (value !== "auto") return value;
    if (type === "filter") {
      return [
        "var(--ui-blur, /*!*/ /*!*/)",
        "var(--ui-brightness, /*!*/ /*!*/)",
        "var(--ui-contrast, /*!*/ /*!*/)",
        "var(--ui-drop-shadow, /*!*/ /*!*/)",
        "var(--ui-grayscale, /*!*/ /*!*/)",
        "var(--ui-hue-rotate, /*!*/ /*!*/)",
        "var(--ui-invert, /*!*/ /*!*/)",
        "var(--ui-opacity, /*!*/ /*!*/)",
        "var(--ui-saturate, /*!*/ /*!*/)",
        "var(--ui-sepia, /*!*/ /*!*/)"
      ].join(" ");
    } else {
      return [
        "var(--ui-backdrop-blur, /*!*/ /*!*/)",
        "var(--ui-backdrop-brightness, /*!*/ /*!*/)",
        "var(--ui-backdrop-contrast, /*!*/ /*!*/)",
        "var(--ui-backdrop-drop-shadow, /*!*/ /*!*/)",
        "var(--ui-backdrop-grayscale, /*!*/ /*!*/)",
        "var(--ui-backdrop-hue-rotate, /*!*/ /*!*/)",
        "var(--ui-backdrop-invert, /*!*/ /*!*/)",
        "var(--ui-backdrop-opacity, /*!*/ /*!*/)",
        "var(--ui-backdrop-saturate, /*!*/ /*!*/)",
        "var(--ui-backdrop-sepia, /*!*/ /*!*/)"
      ].join(" ");
    }
  };
}

// src/config/function.ts
function generateFunction(func) {
  return function(value) {
    return `${func}(${value})`;
  };
}

// src/config/gradient.ts
import { isArray as isArray2, isUndefined as isUndefined2 } from "@yamada-ui/utils";
var directions = {
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-br": "to bottom right",
  "to-l": "to left",
  "to-r": "to right",
  "to-t": "to top",
  "to-tl": "to top left",
  "to-tr": "to top right"
};
var directionValues = new Set(Object.values(directions));
function gradient(value, theme, _css, _prev) {
  if (value == null || globalValues.has(value)) return value;
  const prevent = isCSSFunction(value);
  if (!prevent) return `url('${value}')`;
  let { type, values } = getCSSFunction(value);
  if (!type || !values) return value;
  type = type.includes("-gradient") ? type : `${type}-gradient`;
  const [maybeDirection, ...colors] = splitValues(values);
  if (!colors.length) return value;
  const direction = maybeDirection && maybeDirection in directions ? directions[maybeDirection] : maybeDirection;
  if (!isUndefined2(direction)) colors.unshift(direction);
  const computedValues = colors.map((_color) => {
    var _a, _b;
    if (isUndefined2(_color)) return _color;
    if (directionValues.has(_color)) return _color;
    const i = _color.indexOf(" ");
    let [color, _ratio] = i !== -1 ? [_color.slice(0, i), _color.slice(i + 1)] : [_color];
    const ratio = isCSSFunction(_ratio) ? _ratio : _ratio == null ? void 0 : _ratio.split(" ");
    const token = `colors.${color}`;
    color = theme.__cssMap && token in theme.__cssMap ? (_b = (_a = theme.__cssMap[token]) == null ? void 0 : _a.ref) != null ? _b : color : color;
    if (ratio) {
      return [color, ...isArray2(ratio) ? ratio : [ratio]].join(" ");
    } else {
      return color;
    }
  });
  return `${type}(${computedValues.join(", ")})`;
}

// src/config/grid.ts
var repeats = {
  fill: "auto-fill",
  fit: "auto-fit"
};
function grid(value, theme, css2, prev) {
  if (value == null || globalValues.has(value)) return value;
  const values = splitValues(value, (current) => current === " ");
  if (!values.length) return value;
  const computedValues = values.map((value2) => {
    var _a, _b;
    const prevent = isCSSFunction(value2);
    if (!prevent) {
      const token = `sizes.${value2}`;
      return theme.__cssMap && token in theme.__cssMap ? (_b = (_a = theme.__cssMap[token]) == null ? void 0 : _a.ref) != null ? _b : value2 : value2;
    }
    const { type, values: values2 } = getCSSFunction(value2);
    if (!type || !values2) return value2;
    if (type === "repeat") {
      let [repeat, tracks] = splitValues(values2);
      repeat = repeat && repeat in repeats ? repeats[repeat] : repeat;
      tracks = grid(tracks, theme, css2, prev);
      return `repeat(${repeat}, ${tracks})`;
    } else {
      return generateCalc("sizes")(value2, theme, css2, prev);
    }
  });
  return computedValues.join(" ");
}

// src/config/styles.ts
import { getMemoizedObject as get } from "@yamada-ui/utils";
function generateStyles(prefix) {
  return function(value, theme, _css, prev = {}) {
    const resolvedCSS = {};
    const style = get(
      theme,
      prefix ? `styles.${prefix}.${value}` : `styles.${value}`,
      {}
    );
    for (const prop in style) {
      const done = prop in prev && prev[prop] != null;
      if (!done) resolvedCSS[prop] = style[prop];
    }
    return resolvedCSS;
  };
}

// src/config/token.ts
function generateToken(token) {
  return function(value, theme) {
    return tokenToVar(token, value)(theme);
  };
}

// src/config/transform.ts
var transformValues = [
  "rotate(var(--ui-rotate, 0))",
  "scaleX(var(--ui-scale-x, 1))",
  "scaleY(var(--ui-scale-y, 1))",
  "skewX(var(--ui-skew-x, 0))",
  "skewY(var(--ui-skew-y, 0))"
];
function transform(value, _theme, _css, _prev) {
  if (value === "auto")
    return [
      "translateX(var(--ui-translate-x, 0))",
      "translateY(var(--ui-translate-y, 0))",
      ...transformValues
    ].join(" ");
  if (value === "auto-3d")
    return [
      "translate3d(var(--ui-translate-x, 0), var(--ui-translate-y, 0), 0)",
      ...transformValues
    ].join(" ");
  return value;
}

// src/config/vars.ts
import { flattenObject, isArray as isArray3, isObject as isObject3, isUndefined as isUndefined3 } from "@yamada-ui/utils";

// src/constant.ts
var DEFAULT_VAR_PREFIX = "ui";

// src/config/vars.ts
function insertObject(obj, segments, value) {
  var _a;
  if (segments.length === 0) return value;
  const [head, ...rest] = segments;
  if (!isUndefined3(head)) obj[head] = insertObject((_a = obj[head]) != null ? _a : {}, rest, value);
  return obj;
}
function valueToToken(token, value) {
  return function(theme) {
    const flattedObj = flattenObject(value);
    return Object.entries(flattedObj).reduce((prev, [path, value2]) => {
      const segments = path.split(".");
      if (isArray3(value2)) {
        value2 = value2.map((value3) => tokenToVar(token, value3)(theme));
      } else {
        value2 = tokenToVar(token, value2)(theme);
      }
      insertObject(prev, segments, value2);
      return prev;
    }, {});
  };
}
function replaceValue(token, value) {
  return function(theme) {
    if (!token) return value;
    if (isObject3(value)) {
      value = Object.entries(value).reduce((prev, [key, value2]) => {
        if (isObject3(value2)) {
          prev[key] = valueToToken(token, value2)(theme);
        } else if (isArray3(value2)) {
          prev[key] = value2.map((value3) => {
            if (isObject3(value3)) {
              return valueToToken(token, value3)(theme);
            } else {
              return tokenToVar(token, value3)(theme);
            }
          });
        } else {
          prev[key] = tokenToVar(token, value2)(theme);
        }
        return prev;
      }, {});
    } else if (isArray3(value)) {
      value = value.map((value2) => {
        if (isObject3(value2)) {
          return valueToToken(token, value2)(theme);
        } else {
          return tokenToVar(token, value2)(theme);
        }
      });
    } else {
      value = tokenToVar(token, value)(theme);
    }
    return value;
  };
}
function vars(values, theme, _css, _prev) {
  if (!isArray3(values)) return values;
  return values.reduce((prev, { name, token, value, __prefix }) => {
    var _a, _b, _c;
    const prefix = (_c = __prefix != null ? __prefix : (_b = (_a = theme.__config) == null ? void 0 : _a.var) == null ? void 0 : _b.prefix) != null ? _c : DEFAULT_VAR_PREFIX;
    name = `--${prefix}-${name}`;
    prev[name] = replaceValue(token, value)(theme);
    return prev;
  }, {});
}

// src/config/index.ts
var transforms = {
  animation,
  bgClip: (value) => {
    if (value === "text") {
      return { backgroundClip: "text", color: "transparent" };
    } else {
      return { backgroundClip: value };
    }
  },
  calc: generateCalc,
  colorMix,
  container: generateAtRule("container"),
  content: (value) => {
    if (isObject4(value)) {
      return { content: "''", ...value };
    } else {
      return value;
    }
  },
  deg: (value) => {
    if (isCSSVar(value) || value == null) return value;
    const isUnitless = typeof value === "string" && !value.endsWith("deg");
    return isUnitless || isNumber(value) ? `${value}deg` : value;
  },
  filter: generateFilter,
  fraction: (value) => {
    if (isNumber(value) && value <= 1) value = `${value * 100}%`;
    return value;
  },
  function: generateFunction,
  gradient,
  grid,
  isTruncated: (value) => {
    if (value) {
      return {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      };
    }
  },
  media: generateAtRule("media"),
  px: (value) => {
    if (value == null) return value;
    const { isUnitless } = analyzeCSSValue(value);
    return isUnitless || isNumber(value) ? `${value}px` : value;
  },
  styles: generateStyles,
  supports: generateAtRule("supports"),
  token: generateToken,
  transform,
  vars
};

// src/styles.ts
var standardStyles = {
  accentColor: {
    properties: "accentColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  alignContent: true,
  alignItems: true,
  alignmentBaseline: true,
  alignSelf: true,
  all: true,
  animation: {
    properties: "animation",
    token: "animations",
    transform: pipe(transforms.token("animations"), transforms.animation)
  },
  animationComposition: true,
  animationDelay: true,
  animationDirection: true,
  animationDuration: {
    properties: "animationDuration",
    token: "transitions.duration",
    transform: transforms.token("transitions.duration")
  },
  animationFillMode: true,
  animationIterationCount: true,
  animationName: true,
  animationPlayState: true,
  animationRange: true,
  animationRangeEnd: true,
  animationRangeStart: true,
  animationTimeline: true,
  animationTimingFunction: {
    properties: "animationTimingFunction",
    token: "transitions.easing",
    transform: transforms.token("transitions.easing")
  },
  appearance: true,
  aspectRatio: true,
  azimuth: true,
  backdropBlur: {
    properties: "--ui-backdrop-blur",
    token: "blurs",
    transform: pipe(transforms.token("blurs"), transforms.function("blur"))
  },
  backdropBrightness: {
    properties: "--ui-backdrop-brightness",
    transform: transforms.function("brightness")
  },
  backdropContrast: {
    properties: "--ui-backdrop-contrast",
    transform: transforms.function("contrast")
  },
  backdropDropShadow: {
    properties: "--ui-backdrop-drop-shadow",
    token: "shadows",
    transform: pipe(
      transforms.token("shadows"),
      transforms.function("drop-shadow")
    )
  },
  backdropFilter: { transform: transforms.filter("backdrop") },
  backdropGrayscale: {
    properties: "--ui-backdrop-grayscale",
    transform: transforms.function("grayscale")
  },
  backdropHueRotate: {
    properties: "--ui-backdrop-hue-rotate",
    transform: pipe(transforms.deg, transforms.function("hue-rotate"))
  },
  backdropInvert: {
    properties: "--ui-backdrop-invert",
    transform: transforms.function("invert")
  },
  backdropSaturate: {
    properties: "--ui-backdrop-saturate",
    transform: transforms.function("saturate")
  },
  backdropSepia: {
    properties: "--ui-backdrop-sepia",
    transform: transforms.function("sepia")
  },
  backfaceVisibility: {
    properties: "backfaceVisibility",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  background: {
    properties: "background",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  backgroundAttachment: true,
  backgroundBlendMode: true,
  backgroundClip: {
    properties: "backgroundClip",
    transform: transforms.bgClip
  },
  backgroundColor: {
    properties: "backgroundColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  backgroundImage: {
    properties: "backgroundImage",
    token: "gradients",
    transform: pipe(transforms.token("gradients"), transforms.gradient)
  },
  backgroundOrigin: true,
  backgroundPosition: true,
  backgroundPositionX: true,
  backgroundPositionY: true,
  backgroundRepeat: true,
  backgroundSize: true,
  baselineShift: true,
  blockSize: {
    properties: "blockSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  blur: {
    properties: "--ui-blur",
    token: "blurs",
    transform: pipe(transforms.token("blurs"), transforms.function("blur"))
  },
  border: {
    properties: "border",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderBlock: {
    properties: "borderBlock",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderBlockColor: {
    properties: "borderBlockColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderBlockEnd: {
    properties: "borderBlockEnd",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderBlockEndColor: {
    properties: "borderBlockEndColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderBlockEndStyle: true,
  borderBlockEndWidth: {
    properties: "borderBlockEndWidth",
    transform: transforms.px
  },
  borderBlockStart: {
    properties: "borderBlockStart",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderBlockStartColor: {
    properties: "borderBlockStartColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderBlockStartStyle: true,
  borderBlockStartWidth: {
    properties: "borderBlockStartWidth",
    transform: transforms.px
  },
  borderBlockStyle: true,
  borderBlockWidth: {
    properties: "borderBlockWidth",
    transform: transforms.px
  },
  borderBottom: {
    properties: "borderBottom",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderBottomColor: {
    properties: "borderBottomColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderBottomLeftRadius: {
    properties: "borderBottomLeftRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderBottomRadius: {
    properties: ["borderBottomLeftRadius", "borderBottomRightRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderBottomRightRadius: {
    properties: "borderBottomRightRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderBottomStyle: true,
  borderBottomWidth: {
    properties: "borderBottomWidth",
    transform: transforms.px
  },
  borderCollapse: true,
  borderColor: {
    properties: "borderColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderEndEndRadius: {
    properties: "borderEndEndRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderEndStartRadius: {
    properties: "borderEndStartRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderImage: {
    properties: "borderImage",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderImageOutset: true,
  borderImageRepeat: true,
  borderImageSlice: true,
  borderImageSource: {
    properties: "borderImageSource",
    token: "gradients",
    transform: pipe(transforms.token("gradients"), transforms.gradient)
  },
  borderImageWidth: {
    properties: "borderImageWidth",
    transform: transforms.px
  },
  borderInline: {
    properties: "borderInline",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderInlineColor: {
    properties: "borderInlineColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderInlineEnd: {
    properties: "borderInlineEnd",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderInlineEndColor: {
    properties: "borderInlineEndColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderInlineEndRadius: {
    properties: ["borderEndStartRadius", "borderEndEndRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderInlineEndStyle: true,
  borderInlineEndWidth: {
    properties: "borderInlineEndWidth",
    transform: transforms.px
  },
  borderInlineStart: {
    properties: "borderInlineStart",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderInlineStartColor: {
    properties: "borderInlineStartColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderInlineStartRadius: {
    properties: ["borderStartStartRadius", "borderStartEndRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderInlineStartStyle: true,
  borderInlineStartWidth: {
    properties: "borderInlineStartWidth",
    transform: transforms.px
  },
  borderInlineStyle: true,
  borderInlineWidth: {
    properties: "borderInlineWidth",
    transform: transforms.px
  },
  borderLeft: {
    properties: "borderLeft",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderLeftColor: {
    properties: "borderLeftColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderLeftRadius: {
    properties: ["borderTopLeftRadius", "borderBottomLeftRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderLeftStyle: true,
  borderLeftWidth: { properties: "borderLeftWidth", transform: transforms.px },
  borderRadius: {
    properties: "borderRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderRight: {
    properties: "borderRight",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderRightColor: {
    properties: "borderRightColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderRightRadius: {
    properties: ["borderTopRightRadius", "borderBottomRightRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderRightStyle: true,
  borderRightWidth: {
    properties: "borderRightWidth",
    transform: transforms.px
  },
  borderSpacing: true,
  borderStartEndRadius: {
    properties: "borderStartEndRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderStartStartRadius: {
    properties: "borderStartStartRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderStyle: true,
  borderTop: {
    properties: "borderTop",
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderTopColor: {
    properties: "borderTopColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  borderTopLeftRadius: {
    properties: "borderTopLeftRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderTopRadius: {
    properties: ["borderTopLeftRadius", "borderTopRightRadius"],
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderTopRightRadius: {
    properties: "borderTopRightRadius",
    token: "radii",
    transform: pipe(
      transforms.token("radii"),
      transforms.px,
      transforms.calc("radii")
    )
  },
  borderTopStyle: true,
  borderTopWidth: { properties: "borderTopWidth", transform: transforms.px },
  borderWidth: { properties: "borderWidth", transform: transforms.px },
  borderX: {
    properties: ["borderLeft", "borderRight"],
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  borderY: {
    properties: ["borderTop", "borderBottom"],
    token: "borders",
    transform: pipe(transforms.token("borders"), transforms.px)
  },
  bottom: {
    properties: "bottom",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  boxAlign: true,
  boxDecorationBreak: true,
  boxDirection: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxLines: true,
  boxOrdinalGroup: true,
  boxOrient: true,
  boxPack: true,
  boxShadow: {
    properties: "boxShadow",
    token: "shadows",
    transform: transforms.token("shadows")
  },
  boxSize: {
    properties: ["width", "height"],
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  boxSizing: true,
  breakAfter: true,
  breakBefore: true,
  breakInside: true,
  brightness: {
    properties: "--ui-brightness",
    transform: transforms.function("brightness")
  },
  captionSide: true,
  caretColor: {
    properties: "caretColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  clear: true,
  clip: true,
  clipPath: true,
  clipRule: true,
  color: {
    properties: "color",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  colorInterpolation: true,
  colorMode: { properties: "colorScheme" },
  columnCount: true,
  columnFill: true,
  columnGap: {
    properties: "columnGap",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  columnRule: { properties: "columnRule", transform: transforms.px },
  columnRuleColor: {
    properties: "columnRuleColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  columnRuleStyle: true,
  columnRuleWidth: { properties: "columnRuleWidth", transform: transforms.px },
  columns: true,
  columnSpan: true,
  columnWidth: {
    properties: "columnWidth",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  contain: true,
  container: true,
  containerName: true,
  containerType: true,
  containIntrinsicBlockSize: true,
  containIntrinsicHeight: true,
  containIntrinsicInlineSize: true,
  containIntrinsicSize: true,
  containIntrinsicWidth: {
    properties: "containIntrinsicWidth",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  content: true,
  contentVisibility: true,
  contrast: {
    properties: "--ui-contrast",
    transform: transforms.function("contrast")
  },
  counterIncrement: true,
  counterReset: true,
  counterSet: true,
  cursor: true,
  direction: true,
  display: true,
  dominantBaseline: true,
  dropShadow: {
    properties: "--ui-drop-shadow",
    token: "shadows",
    transform: pipe(
      transforms.token("shadows"),
      transforms.function("drop-shadow")
    )
  },
  emptyCells: true,
  fill: {
    properties: "fill",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  fillOpacity: true,
  fillRule: true,
  filter: { transform: transforms.filter() },
  flex: true,
  flexBasis: {
    properties: "flexBasis",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  flexDirection: true,
  flexFlow: true,
  flexGrow: true,
  flexShrink: true,
  flexWrap: true,
  float: true,
  floodColor: {
    properties: "floodColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  floodOpacity: true,
  font: true,
  fontFamily: {
    properties: "fontFamily",
    token: "fonts",
    transform: transforms.token("fonts")
  },
  fontFeatureSettings: true,
  fontKerning: true,
  fontLanguageOverride: true,
  fontOpticalSizing: true,
  fontPalette: true,
  fontSize: {
    properties: "fontSize",
    token: "fontSizes",
    transform: pipe(
      transforms.token("fontSizes"),
      transforms.px,
      transforms.calc("fontSizes")
    )
  },
  fontSizeAdjust: true,
  fontSmooth: true,
  fontStretch: true,
  fontStyle: true,
  fontSynthesis: true,
  fontSynthesisPosition: true,
  fontSynthesisSmallCaps: true,
  fontSynthesisStyle: true,
  fontSynthesisWeight: true,
  fontVariant: true,
  fontVariantAlternates: true,
  fontVariantCaps: true,
  fontVariantEastAsian: true,
  fontVariantEmoji: true,
  fontVariantLigatures: true,
  fontVariantNumeric: true,
  fontVariantPosition: true,
  fontVariationSettings: true,
  fontWeight: {
    properties: "fontWeight",
    token: "fontWeights",
    transform: transforms.token("fontWeights")
  },
  forcedColorAdjust: true,
  gap: {
    properties: "gap",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  glyphOrientationVertical: true,
  grayscale: {
    properties: "--ui-grayscale",
    transform: transforms.function("grayscale")
  },
  grid: true,
  gridArea: true,
  gridAutoColumns: {
    properties: "gridAutoColumns",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.grid
    )
  },
  gridAutoFlow: true,
  gridAutoRows: {
    properties: "gridAutoRows",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.grid
    )
  },
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnStart: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowStart: true,
  gridTemplate: true,
  gridTemplateAreas: true,
  gridTemplateColumns: {
    properties: "gridTemplateColumns",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.grid
    )
  },
  gridTemplateRows: {
    properties: "gridTemplateRows",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.grid
    )
  },
  hangingPunctuation: true,
  height: {
    properties: "height",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  hueRotate: {
    properties: "--ui-hue-rotate",
    transform: pipe(transforms.deg, transforms.function("hue-rotate"))
  },
  hyphenateCharacter: true,
  hyphenateLimitChars: true,
  hyphens: true,
  imageOrientation: true,
  imageRendering: true,
  imageResolution: true,
  initialLetter: true,
  inlineSize: {
    properties: "inlineSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  inset: {
    properties: "inset",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetBlock: {
    properties: "insetBlock",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetBlockEnd: {
    properties: "insetBlockEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetBlockStart: {
    properties: "insetBlockStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetInline: {
    properties: "insetInline",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetInlineEnd: {
    properties: "insetInlineEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetInlineStart: {
    properties: "insetInlineStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetX: {
    properties: ["left", "right"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  insetY: {
    properties: ["top", "bottom"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  invert: {
    properties: "--ui-invert",
    transform: transforms.function("invert")
  },
  isolation: true,
  justifyContent: true,
  justifyItems: true,
  justifySelf: true,
  left: {
    properties: "left",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  letterSpacing: {
    properties: "letterSpacing",
    token: "letterSpacings",
    transform: transforms.token("letterSpacings")
  },
  lightingColor: {
    properties: "lightingColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  lineBreak: true,
  lineHeight: {
    properties: "lineHeight",
    token: "lineHeights",
    transform: transforms.token("lineHeights")
  },
  lineHeightStep: true,
  listStyle: true,
  listStyleImage: {
    properties: "listStyleImage",
    token: "gradients",
    transform: pipe(transforms.token("gradients"), transforms.gradient)
  },
  listStylePosition: true,
  listStyleType: true,
  margin: {
    properties: "margin",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginBlock: {
    properties: "marginBlock",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginBlockEnd: {
    properties: "marginBlockEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginBlockStart: {
    properties: "marginBlockStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginBottom: {
    properties: "marginBottom",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginInline: {
    properties: "marginInline",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginInlineEnd: {
    properties: "marginInlineEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginInlineStart: {
    properties: "marginInlineStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginLeft: {
    properties: "marginLeft",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginRight: {
    properties: "marginRight",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginTop: {
    properties: "marginTop",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginTrim: true,
  marginX: {
    properties: ["marginInlineStart", "marginInlineEnd"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marginY: {
    properties: ["marginTop", "marginBottom"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  marker: true,
  markerEnd: true,
  markerMid: true,
  markerStart: true,
  mask: true,
  maskBorder: true,
  maskBorderMode: true,
  maskBorderOutset: true,
  maskBorderRepeat: true,
  maskBorderSlice: true,
  maskBorderSource: true,
  maskBorderWidth: { properties: "maskBorderWidth", transform: transforms.px },
  maskClip: true,
  maskComposite: true,
  maskImage: {
    properties: "maskImage",
    token: "gradients",
    transform: pipe(transforms.token("gradients"), transforms.gradient)
  },
  maskMode: true,
  maskOrigin: true,
  maskPosition: true,
  maskRepeat: true,
  maskSize: true,
  maskType: true,
  masonryAutoFlow: true,
  mathDepth: true,
  mathShift: true,
  mathStyle: true,
  maxBlockSize: {
    properties: "maxBlockSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  maxBoxSize: {
    properties: ["maxWidth", "maxHeight"],
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  maxHeight: {
    properties: "maxHeight",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  maxInlineSize: {
    properties: "maxInlineSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  maxWidth: {
    properties: "maxWidth",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  minBlockSize: {
    properties: "minBlockSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  minBoxSize: {
    properties: ["minWidth", "minHeight"],
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  minHeight: {
    properties: "minHeight",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  minInlineSize: {
    properties: "minInlineSize",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  minWidth: {
    properties: "minWidth",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  mixBlendMode: true,
  objectFit: true,
  objectPosition: true,
  offset: true,
  offsetAnchor: true,
  offsetDistance: true,
  offsetPath: true,
  offsetPosition: true,
  offsetRotate: true,
  opacity: true,
  order: true,
  orphans: true,
  outline: true,
  outlineColor: {
    properties: "outlineColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  outlineOffset: true,
  outlineStyle: true,
  outlineWidth: { properties: "outlineWidth", transform: transforms.px },
  overflow: true,
  overflowAnchor: true,
  overflowBlock: true,
  overflowClipMargin: true,
  overflowInline: true,
  overflowWrap: true,
  overflowX: true,
  overflowY: true,
  overlay: true,
  overscrollBehavior: true,
  overscrollBehaviorBlock: true,
  overscrollBehaviorInline: true,
  overscrollBehaviorX: true,
  overscrollBehaviorY: true,
  padding: {
    properties: "padding",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingBlock: {
    properties: "paddingBlock",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingBlockEnd: {
    properties: "paddingBlockEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingBlockStart: {
    properties: "paddingBlockStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingBottom: {
    properties: "paddingBottom",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingInline: {
    properties: "paddingInline",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingInlineEnd: {
    properties: "paddingInlineEnd",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingInlineStart: {
    properties: "paddingInlineStart",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingLeft: {
    properties: "paddingLeft",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingRight: {
    properties: "paddingRight",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingTop: {
    properties: "paddingTop",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingX: {
    properties: ["paddingInlineStart", "paddingInlineEnd"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  paddingY: {
    properties: ["paddingTop", "paddingBottom"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  page: true,
  pageBreakAfter: true,
  pageBreakBefore: true,
  pageBreakInside: true,
  paintOrder: true,
  perspective: true,
  perspectiveOrigin: true,
  placeContent: true,
  placeItems: true,
  placeSelf: true,
  pointerEvents: true,
  position: true,
  printColorAdjust: true,
  quotes: true,
  resize: true,
  right: {
    properties: "right",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  rotate: { properties: "--ui-rotate", transform: transforms.deg },
  rowGap: {
    properties: "rowGap",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  rubyAlign: true,
  rubyPosition: true,
  saturate: {
    properties: "--ui-saturate",
    transform: transforms.function("saturate")
  },
  scale: { properties: ["--ui-scale-x", "--ui-scale-y"] },
  scaleX: { properties: "--ui-scale-x" },
  scaleY: { properties: "--ui-scale-y" },
  scrollbarColor: {
    properties: "scrollbarColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  scrollbarGutter: true,
  scrollbarWidth: { properties: "scrollbarWidth", transform: transforms.px },
  scrollBehavior: true,
  scrollMargin: {
    properties: "scrollMargin",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginBlock: true,
  scrollMarginBlockEnd: true,
  scrollMarginBlockStart: true,
  scrollMarginBottom: {
    properties: "scrollMarginBottom",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginInline: true,
  scrollMarginInlineEnd: true,
  scrollMarginInlineStart: true,
  scrollMarginLeft: {
    properties: "scrollMarginLeft",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginRight: {
    properties: "scrollMarginRight",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginTop: {
    properties: "scrollMarginTop",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginX: {
    properties: ["scrollMarginLeft", "scrollMarginRight"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollMarginY: {
    properties: ["scrollMarginTop", "scrollMarginBottom"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPadding: {
    properties: "scrollPadding",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingBlock: true,
  scrollPaddingBlockEnd: true,
  scrollPaddingBlockStart: true,
  scrollPaddingBottom: {
    properties: "scrollPaddingBottom",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingInline: true,
  scrollPaddingInlineEnd: true,
  scrollPaddingInlineStart: true,
  scrollPaddingLeft: {
    properties: "scrollPaddingLeft",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingRight: {
    properties: "scrollPaddingRight",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingTop: {
    properties: "scrollPaddingTop",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingX: {
    properties: ["scrollPaddingLeft", "scrollPaddingRight"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollPaddingY: {
    properties: ["scrollPaddingTop", "scrollPaddingBottom"],
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  scrollSnapAlign: true,
  scrollSnapStop: true,
  scrollSnapType: true,
  scrollTimeline: true,
  scrollTimelineAxis: true,
  scrollTimelineName: true,
  sepia: { properties: "--ui-sepia", transform: transforms.function("sepia") },
  shapeImageThreshold: true,
  shapeMargin: true,
  shapeOutside: true,
  shapeRendering: true,
  skewX: { properties: "--ui-skew-x", transform: transforms.deg },
  skewY: { properties: "--ui-skew-y", transform: transforms.deg },
  stopColor: true,
  stopOpacity: true,
  stroke: {
    properties: "stroke",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeLinecap: true,
  strokeLinejoin: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: { properties: "strokeWidth", transform: transforms.px },
  tableLayout: true,
  tabSize: true,
  textAlign: true,
  textAlignLast: true,
  textAnchor: true,
  textCombineUpright: true,
  textDecoration: true,
  textDecorationColor: {
    properties: "textDecorationColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  textDecorationLine: true,
  textDecorationSkip: true,
  textDecorationSkipInk: true,
  textDecorationStyle: true,
  textDecorationThickness: true,
  textEmphasis: true,
  textEmphasisColor: {
    properties: "textEmphasisColor",
    token: "colors",
    transform: pipe(transforms.token("colors"), transforms.colorMix)
  },
  textEmphasisPosition: true,
  textEmphasisStyle: true,
  textIndent: true,
  textJustify: true,
  textOrientation: true,
  textOverflow: true,
  textRendering: true,
  textShadow: {
    properties: "textShadow",
    token: "shadows",
    transform: transforms.token("shadows")
  },
  textSizeAdjust: true,
  textTransform: true,
  textUnderlineOffset: true,
  textUnderlinePosition: true,
  textWrap: true,
  timelineScope: true,
  top: {
    properties: "top",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  touchAction: true,
  transform: { properties: "transform", transform: transforms.transform },
  transformBox: true,
  transformOrigin: true,
  transformStyle: true,
  transition: true,
  transitionBehavior: true,
  transitionDelay: true,
  transitionDuration: {
    properties: "transitionDuration",
    token: "transitions.duration",
    transform: transforms.token("transitions.duration")
  },
  transitionProperty: {
    properties: "transitionProperty",
    token: "transitions.property",
    transform: transforms.token("transitions.property")
  },
  transitionTimingFunction: {
    properties: "transitionTimingFunction",
    token: "transitions.easing",
    transform: transforms.token("transitions.easing")
  },
  translate: true,
  translateX: {
    properties: "--ui-translate-x",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  translateY: {
    properties: "--ui-translate-y",
    token: "spaces",
    transform: pipe(
      transforms.token("spaces"),
      transforms.px,
      transforms.calc("spaces")
    )
  },
  unicodeBidi: true,
  userSelect: true,
  vectorEffect: true,
  verticalAlign: true,
  viewTimeline: true,
  viewTimelineAxis: true,
  viewTimelineInset: true,
  viewTimelineName: true,
  viewTransitionName: true,
  visibility: true,
  whiteSpace: true,
  whiteSpaceCollapse: true,
  widows: true,
  width: {
    properties: "width",
    token: "sizes",
    transform: pipe(
      transforms.token("sizes"),
      transforms.fraction,
      transforms.px,
      transforms.calc("sizes")
    )
  },
  willChange: true,
  wordBreak: true,
  wordSpacing: true,
  writingMode: true,
  zIndex: {
    properties: "zIndex",
    token: "zIndices",
    transform: transforms.token("zIndices")
  },
  zoom: true
};
var shorthandStyles = {
  accent: standardStyles.accentColor,
  bg: standardStyles.background,
  bgAttachment: { properties: "backgroundAttachment" },
  bgBlendMode: { properties: "backgroundBlendMode" },
  bgClip: standardStyles.backgroundClip,
  bgColor: standardStyles.backgroundColor,
  bgGradient: standardStyles.backgroundImage,
  bgImage: standardStyles.backgroundImage,
  bgImg: standardStyles.backgroundImage,
  bgOrigin: { properties: "backgroundOrigin" },
  bgPosition: { properties: "backgroundPosition" },
  bgPositionX: { properties: "backgroundPositionX" },
  bgPositionY: { properties: "backgroundPositionY" },
  bgPosX: { properties: "backgroundPositionX" },
  bgPosY: { properties: "backgroundPositionY" },
  bgRepeat: { properties: "backgroundRepeat" },
  bgSize: { properties: "backgroundSize" },
  blendMode: { properties: "mixBlendMode" },
  borderBottomEndRadius: standardStyles.borderEndEndRadius,
  borderBottomStartRadius: standardStyles.borderEndStartRadius,
  borderEnd: standardStyles.borderInlineEnd,
  borderEndColor: standardStyles.borderInlineEndColor,
  borderEndRadius: standardStyles.borderInlineEndRadius,
  borderEndStyle: { properties: "borderInlineEndStyle" },
  borderEndWidth: standardStyles.borderInlineEndWidth,
  borderStart: standardStyles.borderInlineStart,
  borderStartColor: standardStyles.borderInlineStartColor,
  borderStartRadius: standardStyles.borderInlineStartRadius,
  borderStartStyle: { properties: "borderInlineStartStyle" },
  borderStartWidth: standardStyles.borderInlineStartWidth,
  borderTopEndRadius: standardStyles.borderStartEndRadius,
  borderTopStartRadius: standardStyles.borderStartStartRadius,
  caret: standardStyles.caretColor,
  flexDir: { properties: "flexDirection" },
  g: standardStyles.gap,
  gapX: standardStyles.columnGap,
  gapY: standardStyles.rowGap,
  gx: standardStyles.columnGap,
  gy: standardStyles.rowGap,
  h: standardStyles.height,
  insetEnd: standardStyles.insetInlineEnd,
  insetStart: standardStyles.insetInlineStart,
  leading: standardStyles.lineHeight,
  listStyleImg: standardStyles.listStyleImage,
  listStylePos: { properties: "listStylePosition" },
  m: standardStyles.margin,
  marginEnd: standardStyles.marginInlineEnd,
  marginStart: standardStyles.marginInlineStart,
  maxH: standardStyles.maxHeight,
  maxW: standardStyles.maxWidth,
  mb: standardStyles.marginBottom,
  me: standardStyles.marginInlineEnd,
  minH: standardStyles.minHeight,
  minW: standardStyles.minWidth,
  ml: standardStyles.marginLeft,
  mr: standardStyles.marginRight,
  ms: standardStyles.marginInlineStart,
  mt: standardStyles.marginTop,
  mx: standardStyles.marginX,
  my: standardStyles.marginY,
  overscroll: { properties: "overscrollBehavior" },
  overscrollX: { properties: "overscrollBehaviorX" },
  overscrollY: { properties: "overscrollBehaviorY" },
  p: standardStyles.padding,
  paddingEnd: standardStyles.paddingInlineEnd,
  paddingStart: standardStyles.paddingInlineStart,
  pb: standardStyles.paddingBottom,
  pe: standardStyles.paddingInlineEnd,
  pl: standardStyles.paddingLeft,
  pos: { properties: "position" },
  pr: standardStyles.paddingRight,
  ps: standardStyles.paddingInlineStart,
  pt: standardStyles.paddingTop,
  px: standardStyles.paddingX,
  py: standardStyles.paddingY,
  rounded: standardStyles.borderRadius,
  roundedBottom: standardStyles.borderBottomRadius,
  roundedBottomEnd: standardStyles.borderEndEndRadius,
  roundedBottomLeft: standardStyles.borderBottomLeftRadius,
  roundedBottomRight: standardStyles.borderBottomRightRadius,
  roundedBottomStart: standardStyles.borderEndStartRadius,
  roundedEnd: standardStyles.borderInlineEndRadius,
  roundedLeft: standardStyles.borderLeftRadius,
  roundedRight: standardStyles.borderRightRadius,
  roundedStart: standardStyles.borderInlineStartRadius,
  roundedTop: standardStyles.borderTopRadius,
  roundedTopEnd: standardStyles.borderStartEndRadius,
  roundedTopLeft: standardStyles.borderTopLeftRadius,
  roundedTopRight: standardStyles.borderTopRightRadius,
  roundedTopStart: standardStyles.borderStartStartRadius,
  shadow: standardStyles.boxShadow,
  text: standardStyles.fontSize,
  textColor: standardStyles.color,
  textDecor: { properties: "textDecoration" },
  tracking: standardStyles.letterSpacing,
  w: standardStyles.width,
  z: standardStyles.zIndex
};
var pseudoStyles = {
  "&::after": { properties: "&::after", transform: transforms.content },
  "&::before": { properties: "&::before", transform: transforms.content }
};
var uiStyles = {
  apply: { isProcessResult: true, transform: transforms.styles() },
  layerStyle: {
    isProcessResult: true,
    transform: transforms.styles("layerStyles")
  },
  textStyle: {
    isProcessResult: true,
    transform: transforms.styles("textStyles")
  },
  isTruncated: { transform: transforms.isTruncated },
  lineClamp: {
    properties: "--ui-line-clamp",
    static: {
      display: "-webkit-box",
      overflow: "hidden",
      textOverflow: "ellipsis",
      WebkitBoxOrient: "vertical",
      WebkitLineClamp: "var(--ui-line-clamp)"
    }
  },
  vars: { isProcessSkip: true, transform: transforms.vars }
};
var atRuleStyles = {
  _container: { isProcessSkip: true, transform: transforms.container },
  _media: { isProcessSkip: true, transform: transforms.media },
  _supports: { isProcessSkip: true, transform: transforms.supports }
};
var styles = {
  ...standardStyles,
  ...shorthandStyles,
  ...pseudoStyles,
  ...uiStyles,
  ...atRuleStyles
};
var styleProperties = Object.keys(styles);
var processSkipProperties = [
  "vars",
  "_media",
  "_container",
  "_supports"
];
var animationProperties = ["animation"];
var blurProperties = ["blur", "backdropBlur"];
var borderProperties = [
  "border",
  "borderBlock",
  "borderBlockEnd",
  "borderBlockStart",
  "borderBottom",
  "borderImage",
  "borderInline",
  "borderInlineEnd",
  "borderEnd",
  "borderInlineStart",
  "borderStart",
  "borderLeft",
  "borderRight",
  "borderTop",
  "borderY",
  "borderX"
];
var colorProperties = [
  "accentColor",
  "accent",
  "background",
  "bg",
  "backgroundColor",
  "bgColor",
  "borderBlockColor",
  "borderBlockEndColor",
  "borderBlockStartColor",
  "borderBottomColor",
  "borderColor",
  "borderInlineColor",
  "borderInlineEndColor",
  "borderEndColor",
  "borderInlineStartColor",
  "borderStartColor",
  "borderLeftColor",
  "borderRightColor",
  "borderTopColor",
  "caretColor",
  "caret",
  "color",
  "textColor",
  "columnRuleColor",
  "fill",
  "outlineColor",
  "scrollbarColor",
  "stroke",
  "textDecorationColor",
  "textEmphasisColor",
  "floodColor",
  "lightingColor"
];
var fontProperties = [
  "fontFamily",
  "fontSize",
  "text",
  "fontWeight",
  "lineHeight",
  "leading",
  "letterSpacing",
  "tracking"
];
var gradientProperties = [
  "backgroundImage",
  "bgImage",
  "bgImg",
  "bgGradient",
  "borderImageSource",
  "listStyleImage",
  "listStyleImg",
  "maskImage"
];
var radiusProperties = [
  "borderBottomLeftRadius",
  "roundedBottomLeft",
  "borderBottomRightRadius",
  "roundedBottomRight",
  "borderEndEndRadius",
  "borderBottomEndRadius",
  "roundedBottomEnd",
  "borderEndStartRadius",
  "borderBottomStartRadius",
  "roundedBottomStart",
  "borderRadius",
  "rounded",
  "borderStartEndRadius",
  "borderTopEndRadius",
  "roundedTopEnd",
  "borderStartStartRadius",
  "borderTopStartRadius",
  "roundedTopStart",
  "borderTopLeftRadius",
  "roundedTopLeft",
  "borderTopRightRadius",
  "roundedTopRight",
  "borderTopRadius",
  "roundedTop",
  "borderBottomRadius",
  "roundedBottom",
  "borderRightRadius",
  "roundedRight",
  "borderLeftRadius",
  "roundedLeft",
  "borderInlineStartRadius",
  "borderStartRadius",
  "roundedStart",
  "borderInlineEndRadius",
  "borderEndRadius",
  "roundedEnd"
];
var shadowProperties = [
  "boxShadow",
  "shadow",
  "textShadow",
  "dropShadow",
  "backdropDropShadow"
];
var sizeProperties = [
  "backfaceVisibility",
  "blockSize",
  "columnWidth",
  "containIntrinsicWidth",
  "flexBasis",
  "gridAutoColumns",
  "gridAutoRows",
  "gridTemplateColumns",
  "gridTemplateRows",
  "height",
  "h",
  "inlineSize",
  "maxBlockSize",
  "maxHeight",
  "maxH",
  "maxInlineSize",
  "maxWidth",
  "maxW",
  "minBlockSize",
  "minHeight",
  "minH",
  "minInlineSize",
  "minWidth",
  "minW",
  "width",
  "w",
  "boxSize",
  "minBoxSize",
  "maxBoxSize"
];
var spaceProperties = [
  "bottom",
  "columnGap",
  "gx",
  "gapX",
  "gap",
  "g",
  "inset",
  "insetBlock",
  "insetBlockEnd",
  "insetBlockStart",
  "insetInline",
  "insetInlineEnd",
  "insetEnd",
  "insetInlineStart",
  "insetStart",
  "left",
  "margin",
  "m",
  "marginBlock",
  "marginBlockEnd",
  "marginBlockStart",
  "marginBottom",
  "mb",
  "marginInline",
  "marginInlineEnd",
  "me",
  "marginEnd",
  "marginInlineStart",
  "ms",
  "marginStart",
  "marginLeft",
  "ml",
  "marginRight",
  "mr",
  "marginTop",
  "mt",
  "padding",
  "p",
  "paddingBlock",
  "paddingBlockEnd",
  "paddingBlockStart",
  "paddingBottom",
  "pb",
  "paddingInline",
  "paddingInlineEnd",
  "pe",
  "paddingEnd",
  "paddingInlineStart",
  "ps",
  "paddingStart",
  "paddingLeft",
  "pl",
  "paddingRight",
  "pr",
  "paddingTop",
  "pt",
  "right",
  "rowGap",
  "gy",
  "gapY",
  "scrollMargin",
  "scrollMarginBottom",
  "scrollMarginLeft",
  "scrollMarginRight",
  "scrollMarginTop",
  "scrollPadding",
  "scrollPaddingBottom",
  "scrollPaddingLeft",
  "scrollPaddingRight",
  "scrollPaddingTop",
  "top",
  "marginX",
  "mx",
  "marginY",
  "my",
  "paddingX",
  "px",
  "paddingY",
  "py",
  "scrollMarginX",
  "scrollMarginY",
  "scrollPaddingX",
  "scrollPaddingY",
  "insetX",
  "insetY",
  "translateX",
  "translateY"
];
var transitionProperties = [
  "transitionProperty",
  "animationTimingFunction",
  "transitionTimingFunction",
  "animationDuration",
  "transitionDuration"
];
var zIndexProperties = ["zIndex", "z"];
var layoutStyleProperties = [
  "width",
  "inlineSize",
  "height",
  "backfaceVisibility",
  "blockSize",
  "boxSize",
  "minWidth",
  "minInlineSize",
  "minHeight",
  "minBlockSize",
  "maxWidth",
  "maxInlineSize",
  "maxHeight",
  "maxBlockSize",
  "overflow",
  "overflowX",
  "overflowY",
  "overscrollBehavior",
  "overscroll",
  "overscrollX",
  "textDecor",
  "overscrollBehaviorY",
  "overscrollY",
  "display",
  "aspectRatio",
  "verticalAlign",
  "boxSizing",
  "boxDecorationBreak",
  "float",
  "objectFit",
  "objectPosition",
  "visibility",
  "isolation",
  "w",
  "h",
  "minW",
  "maxW",
  "minH",
  "maxH",
  "position",
  "pos",
  "zIndex",
  "inset",
  "insetX",
  "insetInline",
  "insetY",
  "insetBlock",
  "top",
  "insetBlockStart",
  "bottom",
  "insetBlockEnd",
  "left",
  "insetInlineStart",
  "right",
  "insetInlineEnd",
  "insetStart",
  "insetEnd",
  "margin",
  "marginTop",
  "marginBlockStart",
  "marginRight",
  "marginInlineEnd",
  "marginBottom",
  "marginBlockEnd",
  "marginLeft",
  "marginInlineStart",
  "marginX",
  "marginInline",
  "marginY",
  "marginBlock",
  "padding",
  "paddingTop",
  "paddingBlockStart",
  "paddingRight",
  "paddingBottom",
  "paddingBlockEnd",
  "paddingLeft",
  "paddingInlineStart",
  "paddingInlineEnd",
  "paddingX",
  "paddingInline",
  "paddingY",
  "paddingBlock",
  "m",
  "mt",
  "mr",
  "me",
  "marginEnd",
  "mb",
  "ml",
  "ms",
  "marginStart",
  "mx",
  "my",
  "p",
  "pt",
  "py",
  "px",
  "pb",
  "pl",
  "ps",
  "paddingStart",
  "pr",
  "pe",
  "paddingEnd",
  "alignItems",
  "alignContent",
  "justifyItems",
  "justifyContent",
  "flexWrap",
  "flexDirection",
  "flexDir",
  "flex",
  "flexFlow",
  "flexGrow",
  "flexShrink",
  "flexBasis",
  "justifySelf",
  "alignSelf",
  "order",
  "placeItems",
  "placeContent",
  "placeSelf",
  "gap",
  "rowGap",
  "columnGap",
  "grid",
  "gridColumn",
  "gridRow",
  "gridAutoFlow",
  "gridAutoColumns",
  "gridColumnStart",
  "gridColumnEnd",
  "gridRowStart",
  "gridRowEnd",
  "gridAutoRows",
  "gridTemplate",
  "gridTemplateColumns",
  "gridTemplateRows",
  "gridTemplateAreas",
  "gridArea"
];

// src/components/should-forward-prop.ts
var UIProps = /* @__PURE__ */ new Set([
  "__css",
  "as",
  "css",
  "errorBorderColor",
  "focusBorderColor",
  "sx",
  ...pseudoProperties,
  ...styleProperties
]);
function shouldForwardProp(disableStyleProp) {
  return function(prop) {
    var _a;
    return ((_a = disableStyleProp == null ? void 0 : disableStyleProp(prop)) != null ? _a : false) || !UIProps.has(prop);
  };
}

// src/components/use-component-style.tsx
import {
  filterUndefined as filterUndefined2,
  getMemoizedObject as get3,
  isArray as isArray7,
  isObject as isObject9,
  keysFormObject,
  merge as merge7,
  omitObject as omitObject2,
  runIfFunc as runIfFunc4
} from "@yamada-ui/utils";
import { useRef as useRef2 } from "react";
import isEqual from "react-fast-compare";

// src/css/breakpoint.ts
import { getPx } from "@yamada-ui/utils";
function createQuery(min, max, identifier = "@media screen") {
  const query = [identifier];
  if (min) query.push("and", `(min-width: ${min}px)`);
  if (max) query.push("and", `(max-width: ${max}px)`);
  return query.length > 1 ? query.join(" ").replace(/^@container(\s+\w*)?\s+and/, `@container$1`) : void 0;
}
function createQueries(breakpoints, options) {
  const { direction, identifier } = options;
  const isDown = direction !== "up";
  return Object.entries(breakpoints).map(([breakpoint, width], i, entry) => {
    var _a;
    const [, relatedWidth] = (_a = entry[i + 1]) != null ? _a : [];
    let minW = isDown ? relatedWidth : width;
    let maxW = isDown ? width : relatedWidth;
    if (breakpoint === "base") {
      if (isDown) {
        maxW = void 0;
      } else {
        minW = void 0;
      }
    }
    if (isDown) {
      if (minW) minW += 1;
    } else {
      if (maxW) maxW -= 1;
    }
    const maxWQuery = createQuery(void 0, maxW, identifier);
    const minWQuery = createQuery(minW, void 0, identifier);
    const minMaxQuery = createQuery(minW, maxW, identifier);
    const query = isDown ? maxWQuery : minWQuery;
    return {
      breakpoint,
      maxW,
      maxWQuery,
      minMaxQuery,
      minW,
      minWQuery,
      query
    };
  });
}
function transformBreakpoints(breakpoints, options) {
  return Object.fromEntries(
    Object.entries(breakpoints).map(([name, value]) => [name, getPx(value)]).sort((a, b) => {
      if (options.direction !== "up") {
        return b[1] - a[1];
      } else {
        return a[1] - b[1];
      }
    })
  );
}
function analyzeBreakpoints(breakpoints, options = {}) {
  var _a, _b;
  if (!breakpoints) return;
  (_a = options.base) != null ? _a : options.base = "9999px";
  (_b = options.direction) != null ? _b : options.direction = "down";
  breakpoints.base = options.direction !== "up" ? options.base : "0px";
  breakpoints = transformBreakpoints(breakpoints, options);
  const keys = Object.keys(breakpoints);
  const queries2 = createQueries(breakpoints, options);
  const isResponsive = (obj, strict = false) => {
    const providedKeys = Object.keys(obj);
    if (!providedKeys.length) return false;
    if (strict && !providedKeys.includes("base")) return false;
    return providedKeys.every((key) => keys.includes(key));
  };
  return {
    isResponsive,
    keys,
    queries: queries2
  };
}
function getMinMaxQuery(queries2, direction, pickKey = []) {
  const omitQueries = queries2.filter(
    ({ breakpoint }) => breakpoint !== "base" && pickKey.includes(breakpoint)
  );
  const minQuery = omitQueries.sort((a, b) => {
    var _a, _b;
    return ((_a = a.minW) != null ? _a : 0) - ((_b = b.minW) != null ? _b : 0);
  })[0];
  const maxQuery = omitQueries.sort((a, b) => {
    var _a, _b;
    return ((_a = b.maxW) != null ? _a : 0) - ((_b = a.maxW) != null ? _b : 0);
  })[0];
  if (direction !== "up") {
    return { maxQuery, minQuery };
  } else {
    return { maxQuery, minQuery };
  }
}

// src/css/css.ts
import { isArray as isArray4, isObject as isObject5, isString as isString2, merge as merge2, runIfFunc } from "@yamada-ui/utils";
function isProcessSkip(key) {
  return processSkipProperties.includes(key);
}
function isAdditionalObject(obj) {
  return function(breakpointKeys) {
    const keys = Object.keys(obj);
    if (!keys.length) return false;
    if (!keys.includes("base")) return false;
    return keys.every((key) => {
      return breakpointKeys.includes(key) || key.startsWith("@") || key.startsWith("_");
    });
  };
}
function expandColorModeArray(key, value, queries2) {
  let computedCSS = {};
  if (isObject5(value[0])) {
    computedCSS = expandResponsiveObject(key, value[0], queries2);
  } else {
    computedCSS[key] = value[0];
  }
  computedCSS[pseudos._dark] = { [key]: value[1] };
  return computedCSS;
}
function expandResponsiveObject(key, value, queries2) {
  return queries2.reduce((prev, { breakpoint, query }) => {
    const breakpointValue = value[breakpoint];
    if (query) {
      if (breakpointValue) prev[query] = { [key]: breakpointValue };
    } else if (isArray4(breakpointValue)) {
      prev = merge2(prev, expandColorModeArray(key, breakpointValue, queries2));
    } else {
      prev[key] = breakpointValue;
    }
    return prev;
  }, {});
}
function expandAdditionalObject(key, value, queries2) {
  return Object.entries(value).reduce((prev, [query, value2]) => {
    var _a, _b;
    if (query === "base") {
      if (isArray4(value2)) {
        prev = merge2(prev, expandColorModeArray(key, value2, queries2));
      } else {
        prev[key] = value2;
      }
    } else {
      query = (_b = (_a = queries2.find(({ breakpoint }) => breakpoint === query)) == null ? void 0 : _a.query) != null ? _b : query;
      if (isObject5(value2)) {
        prev = merge2(prev, {
          [query]: expandResponsiveObject(key, value2, queries2)
        });
      } else if (isArray4(value2)) {
        prev = merge2(prev, {
          [query]: expandColorModeArray(key, value2, queries2)
        });
      } else {
        prev[query] = { [key]: value2 };
      }
    }
    return prev;
  }, {});
}
function expandCSS(css2) {
  return function(theme) {
    if (!theme.__breakpoints) return css2;
    const { isResponsive, keys, queries: queries2 } = theme.__breakpoints;
    let computedCSS = {};
    for (let [key, value] of Object.entries(css2)) {
      value = runIfFunc(value, theme);
      if (value == null) continue;
      if (isArray4(value) && !isProcessSkip(key)) {
        computedCSS = merge2(
          computedCSS,
          expandColorModeArray(key, value, queries2)
        );
        continue;
      }
      if (isObject5(value) && isResponsive(value) && !isProcessSkip(key)) {
        computedCSS = merge2(
          computedCSS,
          expandResponsiveObject(key, value, queries2)
        );
        continue;
      }
      if (isObject5(value) && isAdditionalObject(value)(keys) && !isProcessSkip(key)) {
        computedCSS = merge2(
          computedCSS,
          expandAdditionalObject(key, value, queries2)
        );
        continue;
      }
      computedCSS = merge2(computedCSS, { [key]: value });
    }
    return computedCSS;
  };
}
function valueToVar(value, theme) {
  var _a, _b, _c;
  if (isArray4(value) || isObject5(value)) {
    return value;
  } else if (isString2(value)) {
    const prefix = (_c = (_b = (_a = theme.__config) == null ? void 0 : _a.var) == null ? void 0 : _b.prefix) != null ? _c : DEFAULT_VAR_PREFIX;
    return value.replace(/\$([^,)/\s]+)/g, (_, value2) => {
      var _a2;
      if (isObject5(theme.__cssMap) && value2 in theme.__cssMap) {
        if ((_a2 = theme.__cssMap[value2]) == null ? void 0 : _a2.ref) return theme.__cssMap[value2].ref;
      }
      return `var(--${prefix}-${value2})`;
    });
  } else {
    return value;
  }
}
function css(cssOrFunc) {
  return function(theme, disableStyleProp) {
    function createCSS(cssOrFunc2, isNested = false) {
      var _a, _b, _c, _d, _e;
      const cssObj = runIfFunc(cssOrFunc2, theme);
      const computedCSS = expandCSS(cssObj)(theme);
      let resolvedCSS = {};
      for (let [prop, value] of Object.entries(computedCSS)) {
        if (disableStyleProp == null ? void 0 : disableStyleProp(prop)) continue;
        value = runIfFunc(value, theme);
        value = valueToVar(value, theme);
        if (value == null) continue;
        if (prop in pseudos) prop = pseudos[prop];
        let style = styles[prop];
        if (style === true) style = { properties: prop };
        if (isObject5(value) && !(style == null ? void 0 : style.isProcessSkip)) {
          value = (_b = (_a = style == null ? void 0 : style.transform) == null ? void 0 : _a.call(style, value, theme, css, resolvedCSS)) != null ? _b : value;
          resolvedCSS[prop] = (_c = resolvedCSS[prop]) != null ? _c : {};
          resolvedCSS[prop] = merge2(resolvedCSS[prop], createCSS(value, true));
          continue;
        }
        value = (_e = (_d = style == null ? void 0 : style.transform) == null ? void 0 : _d.call(style, value, theme, css, resolvedCSS)) != null ? _e : value;
        if ((style == null ? void 0 : style.isProcessResult) || (style == null ? void 0 : style.isProcessSkip))
          value = createCSS(value, true);
        if (!isNested && (style == null ? void 0 : style.static)) {
          const staticStyles = runIfFunc(style.static, theme);
          resolvedCSS = merge2(resolvedCSS, staticStyles);
        }
        const properties = runIfFunc(style == null ? void 0 : style.properties, theme);
        if (properties) {
          if (isArray4(properties)) {
            for (const property of properties) {
              resolvedCSS[property] = value;
            }
            continue;
          } else if (isObject5(value)) {
            resolvedCSS = merge2(resolvedCSS, value);
            continue;
          } else {
            resolvedCSS[properties] = value;
            continue;
          }
        }
        if (isObject5(value)) {
          resolvedCSS = merge2(resolvedCSS, value);
          continue;
        }
        resolvedCSS[prop] = value;
      }
      return resolvedCSS;
    }
    return createCSS(cssOrFunc);
  };
}

// src/css/use-css.ts
import { css as emotionCSS } from "@emotion/css";
import { ThemeContext } from "@emotion/react";
import { useContext, useMemo } from "react";
var useCSS = (cssObject = {}) => {
  const theme = useContext(ThemeContext);
  return useMemo(() => getCSS(cssObject)(theme), [cssObject, theme]);
};
var getCSS = (cssObject = {}) => (theme) => emotionCSS(css(cssObject)(theme));

// src/css/use-var.ts
import { ThemeContext as ThemeContext2 } from "@emotion/react";
import { flattenObject as flattenObject2, isObject as isObject6, merge as merge3 } from "@yamada-ui/utils";
import { useContext as useContext2, useMemo as useMemo2 } from "react";
var defaultFormat = (name, index) => `${name}-${index}`;
var useCreateVars = (obj, keys, options) => {
  const theme = useContext2(ThemeContext2);
  return useMemo2(
    () => createVars(obj, keys, options)(theme),
    [obj, keys, options, theme]
  );
};
var createVars = (obj, keys, { format = defaultFormat, transform: transform2 = false } = {}) => (theme) => {
  var _a, _b, _c;
  const map = /* @__PURE__ */ new Map();
  const result = {};
  if (!theme.__breakpoints) return [[], result];
  const { isResponsive } = theme.__breakpoints;
  const prefix = (_c = (_b = (_a = theme.__config) == null ? void 0 : _a.var) == null ? void 0 : _b.prefix) != null ? _c : DEFAULT_VAR_PREFIX;
  const flattedObj = flattenObject2(obj, {
    separator: "$$",
    shouldProcess: (obj2) => !isResponsive(obj2)
  });
  Object.entries(flattedObj).forEach(([path, value], index) => {
    const segments = path.split("$$");
    if (!segments.some((path2) => keys.includes(path2))) return;
    const name = segments.at(-1);
    const rest = segments.slice(0, -1);
    if (map.has(name)) {
      const variable = map.get(name);
      if (!variable) return;
      const additionalValue = rest.reduceRight(
        (acc, key) => ({ [key]: acc }),
        isObject6(value) ? value : { base: value }
      );
      value = merge3(variable.value, additionalValue);
      map.set(name, { ...variable, value });
    } else {
      const formattedName = format(name, index);
      const style = styles[name];
      const token = isObject6(style) ? style.token : void 0;
      const additionalValue = rest.reduceRight(
        (acc, key) => ({ [key]: acc }),
        isObject6(value) ? value : { base: value }
      );
      value = { base: void 0, ...additionalValue };
      map.set(name, {
        name: formattedName,
        token,
        value,
        __prefix: prefix
      });
      if (transform2) {
        result[name] = `var(--${prefix}-${formattedName})`;
      } else {
        result[name] = `$${formattedName}`;
      }
    }
  });
  const variables = [...map.values()];
  return [variables, result];
};
var mergeVars = (...vars2) => vars2.filter(Boolean).flatMap((vars3) => vars3);

// src/css/var.ts
import {
  calc,
  escape,
  isArray as isArray5,
  isObject as isObject7,
  isString as isString3,
  merge as merge4
} from "@yamada-ui/utils";
function getVar(token) {
  return function(theme) {
    var _a, _b, _c;
    const prefix = (_c = (_b = (_a = theme.__config) == null ? void 0 : _a.var) == null ? void 0 : _b.prefix) != null ? _c : DEFAULT_VAR_PREFIX;
    return `var(--${prefix}-${token})`;
  };
}
var isGradient = (token) => token.startsWith("gradients.");
var isAnimation = (token) => token.startsWith("animations.");
var isSpace = (token) => token.startsWith("spaces.");
function getCreateThemeVars(prefix = DEFAULT_VAR_PREFIX, queries2) {
  function tokenToVar2(token) {
    token = token.replace(/\./g, "-");
    const variable = `--${[prefix, escape(token, "-")].filter(Boolean).join("-")}`;
    const reference = `var(${variable})`;
    return { reference, variable };
  }
  return function(tokens) {
    return function({
      cssMap = {},
      cssVars = {},
      prevTokens
    } = {}) {
      const theme = { __cssMap: cssMap };
      function getRelatedReference(token, value = "") {
        var _a;
        const relatedToken = [token.split(".")[0], value].join(".");
        const targetToken = (_a = tokens[relatedToken]) != null ? _a : prevTokens == null ? void 0 : prevTokens[relatedToken];
        if (!targetToken) return [, value];
        const { reference, variable } = tokenToVar2(relatedToken);
        return [variable, reference];
      }
      function getQuery(key) {
        var _a;
        return (_a = queries2.find(({ breakpoint }) => breakpoint === key)) == null ? void 0 : _a.query;
      }
      function valueToVar2(value) {
        if (isString3(value)) {
          return value.replace(/\$([^,)/\s]+)/g, (_, value2) => {
            var _a, _b;
            const token = (_a = tokens[value2]) != null ? _a : prevTokens == null ? void 0 : prevTokens[value2];
            if (token) {
              return tokenToVar2(value2).reference;
            } else if (value2 in cssMap && ((_b = cssMap[value2]) == null ? void 0 : _b.ref)) {
              return cssMap[value2].ref;
            } else {
              return `var(--${prefix}-${value2})`;
            }
          });
        } else {
          return value;
        }
      }
      function createNegativeVar(token, reference) {
        const paths = token.split(".");
        const [start, ...rest] = paths;
        const negativeToken = `${start}.-${rest.join(".")}`;
        const negativeReference = calc.negate(reference);
        return { negativeReference, negativeToken };
      }
      function createAnimationVar(value) {
        if (isArray5(value)) {
          return value.map((value2) => animation(value2, theme, css)).join(",");
        } else {
          return animation(value, theme, css);
        }
      }
      function createGradientVar(token, value) {
        return function(isSemantic) {
          if (!isSemantic) {
            return gradient(value, theme, css);
          } else {
            const [variable, reference] = getRelatedReference(token, value);
            return variable ? reference : gradient(value, theme, css);
          }
        };
      }
      function createVar(token, value, variable) {
        return function(isSemantic, queries3 = []) {
          if (isArray5(value)) {
            const [lightValue, darkValue] = value;
            createVar(token, lightValue, variable)(isSemantic, queries3);
            createVar(
              token,
              darkValue,
              variable
            )(isSemantic, [...queries3, pseudos._dark]);
          } else if (isObject7(value)) {
            Object.entries(value).forEach(([key, value2]) => {
              if (key === "base") {
                createVar(token, value2, variable)(isSemantic, queries3);
              } else {
                const query = getQuery(key);
                if (!query) return;
                createVar(
                  token,
                  value2,
                  variable
                )(isSemantic, [...queries3, query]);
              }
            });
          } else {
            let computedValue = valueToVar2(value);
            if (isGradient(token)) {
              computedValue = createGradientVar(
                token,
                computedValue
              )(isSemantic);
            } else if (isSemantic) {
              const [, reference] = getRelatedReference(token, computedValue);
              computedValue = reference;
            }
            cssVars = merge4(
              cssVars,
              queries3.reduceRight((prev, key) => ({ [key]: prev }), {
                [variable]: computedValue
              })
            );
          }
        };
      }
      for (let [token, { isSemantic, value }] of Object.entries(tokens)) {
        const { reference, variable } = tokenToVar2(token);
        if (isAnimation(token)) value = createAnimationVar(value);
        createVar(token, value, variable)(isSemantic);
        if (isSpace(token)) {
          const { negativeReference, negativeToken } = createNegativeVar(
            token,
            reference
          );
          cssMap[negativeToken] = { ref: negativeReference, var: variable };
        }
        cssMap[token] = { ref: reference, var: variable };
      }
      return { cssMap, cssVars };
    };
  };
}

// src/providers/color-mode-script.tsx
import { jsx } from "react/jsx-runtime";
var COLOR_MODE_STORAGE_KEY = "ui-color-mode";
var COLOR_MODE_MAP = /* @__PURE__ */ new Set(["dark", "light", "system"]);
var normalizeColorMode = (initialColorMode) => {
  let value = initialColorMode;
  if (!COLOR_MODE_MAP.has(value)) value = "light";
  return value;
};
var getColorModeScript = ({
  type = "localStorage",
  initialColorMode = "light",
  storageKey = COLOR_MODE_STORAGE_KEY
} = {}) => {
  const init = normalizeColorMode(initialColorMode);
  const isCookie = type === "cookie";
  const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,m=document.body,i="ui-light",n="ui-dark",s=e==="dark";return m.classList.add(s?n:i),m.classList.remove(s?i:n),d.style.colorScheme=e,d.dataset.mode=e,e},h="${init}",r="${storageKey}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();
  `;
  const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,s=document.body,l="ui-light",d="ui-dark",i=r==="dark";return s.classList.add(i?d:l),s.classList.remove(i?l:d),o.style.colorScheme=r,o.dataset.mode=r,r},m="${init}",e="${storageKey}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();
  `;
  const fn = isCookie ? cookieScript : localStorageScript;
  return `!${fn}`.trim();
};
var ColorModeScript = ({ nonce, ...rest }) => {
  const html = getColorModeScript(rest);
  return /* @__PURE__ */ jsx(
    "script",
    {
      id: "ui-color-mode-script",
      dangerouslySetInnerHTML: { __html: html },
      nonce
    }
  );
};

// src/providers/color-mode-manager.ts
var hasSupport = !!globalThis.document;
var createLocalStorage = (defaultStorageKey) => ({
  type: "localStorage",
  get: (initColorMode = "light") => (storageKey = defaultStorageKey) => {
    if (!hasSupport) return initColorMode;
    try {
      const colorMode = localStorage.getItem(storageKey);
      return colorMode || initColorMode;
    } catch {
      return initColorMode;
    }
  },
  set: (colorMode) => (storageKey = defaultStorageKey) => {
    try {
      localStorage.setItem(storageKey, colorMode);
    } catch {
    }
  },
  ssr: false
});
var parseCookie = (cookie, key) => {
  const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match == null ? void 0 : match[2];
};
var createCookieStorage = (defaultStorageKey, cookie) => ({
  type: "cookie",
  get: (initColorMode = "light") => (storageKey = defaultStorageKey) => {
    if (cookie) return parseCookie(cookie, storageKey) || initColorMode;
    if (!hasSupport) return initColorMode;
    return parseCookie(document.cookie, storageKey) || initColorMode;
  },
  set: (colorMode) => (storageKey = defaultStorageKey) => {
    document.cookie = `${storageKey}=${colorMode}; max-age=31536000; path=/`;
  },
  ssr: !!cookie
});
var createColorModeManager = (type = "local", cookie) => {
  switch (type) {
    case "cookie":
    case "ssr":
      return createCookieStorage(
        COLOR_MODE_STORAGE_KEY,
        typeof cookie === "string" ? cookie : void 0
      );
    default:
      return createLocalStorage(COLOR_MODE_STORAGE_KEY);
  }
};
var colorModeManager = {
  cookieStorage: createCookieStorage(COLOR_MODE_STORAGE_KEY),
  createCookieStorage,
  createLocalStorage,
  localStorage: createLocalStorage(COLOR_MODE_STORAGE_KEY),
  ssr: (cookie) => createCookieStorage(COLOR_MODE_STORAGE_KEY, cookie)
};

// src/providers/color-mode-provider.tsx
import {
  funcAll,
  isEmptyObject,
  noop,
  useCallbackRef,
  useSafeLayoutEffect as useSafeLayoutEffect2
} from "@yamada-ui/utils";
import {
  createContext as createContext2,
  useCallback,
  useContext as useContext4,
  useEffect,
  useMemo as useMemo4,
  useState
} from "react";

// src/providers/environment-provider.tsx
import { useSafeLayoutEffect } from "@yamada-ui/utils";
import { createContext, useContext as useContext3, useMemo as useMemo3, useReducer, useRef } from "react";
import { jsx as jsx2, jsxs } from "react/jsx-runtime";
var defaultEnvironment = {
  getDocument: () => document,
  getWindow: () => window
};
var EnvironmentContext = createContext(defaultEnvironment);
var EnvironmentProvider = ({
  children,
  disabled,
  environment
}) => {
  const ref = useRef(null);
  const context = useMemo3(() => {
    if (environment) return environment;
    return {
      getDocument: () => {
        var _a, _b;
        return (_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
      },
      getWindow: () => {
        var _a, _b;
        return (_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument.defaultView) != null ? _b : window;
      }
    };
  }, [environment]);
  const enabled = !disabled || !environment;
  return /* @__PURE__ */ jsxs(EnvironmentContext.Provider, { value: context, children: [
    children,
    enabled ? /* @__PURE__ */ jsx2("span", { id: "__ui_dev", ref, hidden: true }) : null
  ] });
};
EnvironmentProvider.displayName = "EnvironmentProvider";
var useEnvironment = ({ isDefer } = {}) => {
  const [, forceUpdate] = useReducer((c) => c + 1, 0);
  useSafeLayoutEffect(() => {
    if (!isDefer) return;
    forceUpdate();
  }, [isDefer]);
  return useContext3(EnvironmentContext);
};

// src/providers/provider-utils.ts
var preventTransition = (environment) => {
  const { getDocument, getWindow } = environment;
  const win = getWindow();
  const doc = getDocument();
  if (!doc) return;
  const css2 = doc.createElement("style");
  const node = doc.createTextNode(
    `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
  );
  css2.appendChild(node);
  doc.head.appendChild(css2);
  return () => {
    const forceReflow = () => win == null ? void 0 : win.getComputedStyle(doc.body);
    forceReflow();
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        document.head.removeChild(css2);
      });
    });
  };
};

// src/providers/color-mode-utils.ts
var classNames = {
  light: "ui-light",
  dark: "ui-dark"
};
var queries = {
  light: "(prefers-color-scheme: light)",
  dark: "(prefers-color-scheme: dark)"
};
var getColorModeUtils = ({
  environment = defaultEnvironment,
  isPreventTransition = true
}) => {
  const { getDocument, getWindow } = environment;
  const setDataset = (colorMode) => {
    const doc = getDocument();
    const cleanup = isPreventTransition ? preventTransition(environment) : void 0;
    if (!doc) return;
    doc.documentElement.dataset.mode = colorMode;
    doc.documentElement.style.colorScheme = colorMode;
    cleanup == null ? void 0 : cleanup();
  };
  const setClassName = (isDark) => {
    const doc = getDocument();
    if (!doc) return;
    doc.body.classList.add(isDark ? classNames.dark : classNames.light);
    doc.body.classList.remove(isDark ? classNames.light : classNames.dark);
  };
  const query = () => {
    const win = getWindow();
    if (!win) return;
    return win.matchMedia(queries.dark);
  };
  const getSystemColorMode = (fallback) => {
    var _a;
    const mql = query();
    const dark = (_a = mql == null ? void 0 : mql.matches) != null ? _a : fallback === "dark";
    return dark ? "dark" : "light";
  };
  const systemColorModeObserver = (func) => {
    const mql = query();
    const listener = (e) => {
      func(e.matches ? "dark" : "light");
    };
    if (typeof (mql == null ? void 0 : mql.addListener) === "function") {
      mql.addListener(listener);
    } else {
      mql == null ? void 0 : mql.addEventListener("change", listener);
    }
    return () => {
      if (typeof (mql == null ? void 0 : mql.removeListener) === "function") {
        mql.removeListener(listener);
      } else {
        mql == null ? void 0 : mql.removeEventListener("change", listener);
      }
    };
  };
  return {
    getSystemColorMode,
    query,
    setClassName,
    setDataset,
    systemColorModeObserver
  };
};

// src/providers/color-mode-provider.tsx
import { jsx as jsx3 } from "react/jsx-runtime";
var { localStorage: localStorage2 } = colorModeManager;
var getColorMode = (manager, fallback) => (storageKey) => manager.type === "cookie" && manager.ssr ? manager.get(fallback)(storageKey) : fallback;
var ColorModeContext = createContext2({});
var ColorModeProvider = ({
  children,
  colorMode: defaultColorMode,
  colorModeManager: colorModeManager2 = localStorage2,
  config: {
    disableTransitionOnChange = true,
    initialColorMode = "light"
  } = {},
  storageKey
}) => {
  const environment = useEnvironment();
  const [colorMode, setColorMode] = useState(
    () => getColorMode(colorModeManager2, initialColorMode)(storageKey)
  );
  const systemColorMode = useSystemColorMode({
    callback: (systemColorMode2) => {
      if (colorMode !== "system") return;
      setClassName(systemColorMode2 === "dark");
      setDataset(systemColorMode2);
    },
    environment
  });
  const computedColorMode = initialColorMode === "dark" ? "dark" : "light";
  const resolvedColorMode = colorMode === "system" ? systemColorMode ? systemColorMode : computedColorMode : colorMode;
  const { getSystemColorMode, setClassName, setDataset } = useMemo4(
    () => getColorModeUtils({
      environment,
      isPreventTransition: disableTransitionOnChange
    }),
    [disableTransitionOnChange, environment]
  );
  const changeColorMode = useCallback(
    (colorMode2) => {
      const resolved = colorMode2 === "system" ? getSystemColorMode() : colorMode2;
      setColorMode(colorMode2);
      setClassName(resolved === "dark");
      setDataset(resolved);
      colorModeManager2.set(colorMode2)(storageKey);
    },
    [
      colorModeManager2,
      getSystemColorMode,
      setClassName,
      setDataset,
      storageKey
    ]
  );
  const toggleColorMode = useCallback(() => {
    changeColorMode(resolvedColorMode === "dark" ? "light" : "dark");
  }, [changeColorMode, resolvedColorMode]);
  useEffect(() => {
    const managerValue = colorModeManager2.get()(storageKey);
    changeColorMode(managerValue);
  }, [changeColorMode, colorModeManager2, storageKey]);
  const value = useMemo4(
    () => ({
      changeColorMode: defaultColorMode ? noop : changeColorMode,
      colorMode: defaultColorMode != null ? defaultColorMode : resolvedColorMode,
      forced: defaultColorMode !== void 0,
      internalColorMode: colorMode,
      toggleColorMode: defaultColorMode ? noop : toggleColorMode
    }),
    [
      defaultColorMode,
      resolvedColorMode,
      colorMode,
      changeColorMode,
      toggleColorMode
    ]
  );
  return /* @__PURE__ */ jsx3(ColorModeContext.Provider, { value, children });
};
var useColorMode = () => {
  const context = useContext4(ColorModeContext);
  if (isEmptyObject(context)) {
    return {
      changeColorMode: noop,
      colorMode: "light",
      forced: false,
      internalColorMode: "light",
      toggleColorMode: noop
    };
  } else {
    return context;
  }
};
var useSystemColorMode = ({
  callback,
  environment,
  initialColorMode
} = {}) => {
  const callbackRef = useCallbackRef(callback);
  const [colorMode, setColorMode] = useState(
    initialColorMode
  );
  const { getSystemColorMode, systemColorModeObserver } = useMemo4(
    () => getColorModeUtils({ environment }),
    [environment]
  );
  useSafeLayoutEffect2(() => {
    setColorMode(getSystemColorMode());
  }, [getSystemColorMode]);
  useEffect(() => {
    return systemColorModeObserver(funcAll(setColorMode, callbackRef));
  }, [systemColorModeObserver, getSystemColorMode, callbackRef]);
  return colorMode;
};
var useColorModeValue = (light, dark) => {
  const { colorMode } = useColorMode();
  return getColorModeValue(light, dark)(colorMode);
};
var getColorModeValue = (light, dark) => (colorMode) => {
  return colorMode === "light" ? light : dark;
};

// src/providers/theme-script.tsx
import { jsx as jsx4 } from "react/jsx-runtime";
var THEME_SCHEME_STORAGE_KEY = "ui-theme-scheme";
var getThemeSchemeScript = ({
  type = "localStorage",
  initialThemeScheme: init = "base",
  storageKey = THEME_SCHEME_STORAGE_KEY
} = {}) => {
  const isCookie = type === "cookie";
  const cookieScript = `(function(){try{var a=function(c){var o=document.documentElement;return o.dataset.theme=c,c},h='${init}',r='${storageKey}',t=document.cookie.match(new RegExp('(^| )'.concat(r,'=([^;]+)'))),c=t?t[2]:null;c?a(c):(document.cookie=''.concat(r,'=').concat(a(h),'; max-age=31536000; path=/'))}catch(a){}})();`;
  const localStorageScript = `(function(){try{var a=function(c){var o=document.documentElement;return o.dataset.theme=c,c},m='${init}',e='${storageKey}',t=localStorage.getItem(e);t?a(t):localStorage.setItem(e, a(m))}catch(a){}})();`;
  const fn = isCookie ? cookieScript : localStorageScript;
  return `!${fn}`.trim();
};
var ThemeSchemeScript = ({
  nonce,
  ...rest
}) => {
  const html = getThemeSchemeScript(rest);
  return /* @__PURE__ */ jsx4(
    "script",
    {
      id: "ui-theme-script",
      dangerouslySetInnerHTML: { __html: html },
      nonce
    }
  );
};

// src/providers/theme-manager.ts
var hasSupport2 = !!globalThis.document;
var createLocalStorage2 = (defaultStorageKey) => ({
  type: "localStorage",
  get: (initThemeScheme = "base") => (storageKey = defaultStorageKey) => {
    if (!hasSupport2) return initThemeScheme;
    try {
      const themeScheme = localStorage.getItem(storageKey);
      return themeScheme || initThemeScheme;
    } catch {
      return initThemeScheme;
    }
  },
  set: (themeScheme) => (storageKey = defaultStorageKey) => {
    try {
      localStorage.setItem(storageKey, String(themeScheme));
    } catch {
    }
  },
  ssr: false
});
var parseCookie2 = (cookie, key) => {
  const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match == null ? void 0 : match[2];
};
var createCookieStorage2 = (defaultStorageKey, cookie) => ({
  type: "cookie",
  get: (initThemeScheme = "base") => (storageKey = defaultStorageKey) => {
    if (cookie) return parseCookie2(cookie, storageKey) || initThemeScheme;
    if (!hasSupport2) return initThemeScheme;
    return parseCookie2(document.cookie, storageKey) || initThemeScheme;
  },
  set: (themeScheme) => (storageKey = defaultStorageKey) => {
    document.cookie = `${storageKey}=${themeScheme}; max-age=31536000; path=/`;
  },
  ssr: !!cookie
});
var createThemeSchemeManager = (type = "local", cookie) => {
  switch (type) {
    case "cookie":
    case "ssr":
      return createCookieStorage2(
        THEME_SCHEME_STORAGE_KEY,
        typeof cookie === "string" ? cookie : void 0
      );
    default:
      return createLocalStorage2(THEME_SCHEME_STORAGE_KEY);
  }
};
var themeSchemeManager = {
  cookieStorage: createCookieStorage2(THEME_SCHEME_STORAGE_KEY),
  createCookieStorage: createCookieStorage2,
  createLocalStorage: createLocalStorage2,
  localStorage: createLocalStorage2(THEME_SCHEME_STORAGE_KEY),
  ssr: (cookie) => createCookieStorage2(THEME_SCHEME_STORAGE_KEY, cookie)
};

// src/providers/theme-provider.tsx
import {
  ThemeProvider as EmotionThemeProvider,
  Global,
  ThemeContext as ThemeContext3
} from "@emotion/react";
import {
  getMemoizedObject as get2,
  isEmptyObject as isEmptyObject2,
  isUndefined as isUndefined4,
  merge as merge6,
  runIfFunc as runIfFunc3
} from "@yamada-ui/utils";
import { useCallback as useCallback2, useContext as useContext5, useEffect as useEffect2, useMemo as useMemo5, useState as useState2 } from "react";

// src/theme.ts
import {
  flattenObject as flattenObject3,
  isArray as isArray6,
  isFunction,
  isObject as isObject8,
  merge as merge5,
  objectFromEntries,
  omitObject,
  pickObject,
  runIfFunc as runIfFunc2,
  TONES
} from "@yamada-ui/utils";
var primaryTokens = [
  "blurs",
  "borders",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "letterSpacings",
  "lineHeights",
  "radii",
  "shadows",
  "sizes",
  "spaces",
  "zIndices"
];
var secondaryTokens = ["gradients"];
function transformTheme(theme, config) {
  var _a, _b;
  theme = omitTheme(theme);
  const prefix = (_a = config == null ? void 0 : config.var) == null ? void 0 : _a.prefix;
  const breakpoints = analyzeBreakpoints(theme.breakpoints, config == null ? void 0 : config.breakpoint);
  const createThemeTokens = getCreateThemeTokens(
    breakpoints,
    (_b = config == null ? void 0 : config.theme) == null ? void 0 : _b.responsive
  );
  const { queries: queries2 = [] } = breakpoints != null ? breakpoints : {};
  const createThemeVars = getCreateThemeVars(prefix, queries2);
  const primaryTokens2 = createThemeTokens(theme);
  const secondaryTokens2 = createThemeTokens(theme, "secondary");
  const animationTokens = createThemeTokens(theme, "animation");
  let { cssMap, cssVars } = mergeVars2(
    createThemeVars(primaryTokens2),
    createThemeVars(secondaryTokens2),
    createThemeVars(animationTokens)
  )();
  if (theme.themeSchemes) {
    for (const [themeScheme, nestedTheme] of Object.entries(
      theme.themeSchemes
    )) {
      const nestedPrimaryTokens = createThemeTokens(nestedTheme);
      const nestedSecondaryTokens = createThemeTokens(nestedTheme, "secondary");
      const nestedAnimationTokens = createThemeTokens(nestedTheme, "animation");
      let { cssVars: nestedCSSVars } = mergeVars2(
        createThemeVars(nestedPrimaryTokens),
        createThemeVars(nestedSecondaryTokens),
        createThemeVars(nestedAnimationTokens)
      )({ ...primaryTokens2, ...secondaryTokens2, ...animationTokens });
      cssVars = {
        ...cssVars,
        [`[data-theme=${themeScheme}] &:not([data-theme]), &[data-theme=${themeScheme}]`]: nestedCSSVars
      };
    }
  }
  Object.assign(theme, {
    __breakpoints: breakpoints,
    __config: config,
    __cssMap: cssMap,
    __cssVars: cssVars
  });
  return theme;
}
function getCreateThemeTokens(breakpoints, responsive) {
  return function(theme, target = "primary") {
    var _a;
    let shouldProcess = void 0;
    let defaultTokens = [];
    let semanticTokens = [];
    let omitKeys = [];
    if (responsive)
      shouldProcess = (obj) => !(breakpoints == null ? void 0 : breakpoints.isResponsive(obj, true));
    switch (target) {
      case "primary":
        defaultTokens = [...primaryTokens, "transitions"];
        semanticTokens = [...primaryTokens, "transitions", "colorSchemes"];
        break;
      case "secondary":
        defaultTokens = [...secondaryTokens];
        semanticTokens = [...secondaryTokens];
        break;
      case "animation":
        defaultTokens = ["animations"];
        semanticTokens = ["animations"];
        omitKeys = ["keyframes"];
        break;
      default:
        break;
    }
    const defaultTokenMap = pickObject(theme, defaultTokens);
    const semanticTokenMap = pickObject((_a = theme.semantics) != null ? _a : {}, semanticTokens);
    const defaultTokenEntries = Object.entries(
      flattenObject3(defaultTokenMap, { omitKeys, shouldProcess })
    ).map(([token, value]) => {
      const enhancedToken = { isSemantic: false, value };
      return [token, enhancedToken];
    });
    const semanticTokenEntries = Object.entries(
      flattenObject3(semanticTokenMap, { omitKeys, shouldProcess })
    ).reduce((prev, [token, value]) => {
      if (token.startsWith("colorSchemes.")) {
        const [, semanticToken, tone] = token.split(".");
        if (tone) {
          const enhancedToken = { isSemantic: false, value };
          prev.push([`colors.${semanticToken}.${tone}`, enhancedToken]);
        } else {
          TONES.forEach((tone2) => {
            const enhancedToken = {
              isSemantic: true,
              value: isArray6(value) ? [`${value[0]}.${tone2}`, `${value[1]}.${tone2}`] : `${value}.${tone2}`
            };
            prev.push([`colors.${semanticToken}.${tone2}`, enhancedToken]);
          });
        }
      } else {
        const enhancedToken = { isSemantic: true, value };
        prev.push([token, enhancedToken]);
      }
      return prev;
    }, []);
    return objectFromEntries([
      ...defaultTokenEntries,
      ...semanticTokenEntries
    ]);
  };
}
function mergeVars2(...funcs) {
  return function(prevTokens) {
    let resolvedCSSMap = {};
    let resolvedCSSVars = {};
    for (const func of funcs) {
      const { cssMap, cssVars } = func({
        cssMap: resolvedCSSMap,
        cssVars: resolvedCSSVars,
        prevTokens
      });
      resolvedCSSMap = { ...resolvedCSSMap, ...cssMap };
      resolvedCSSVars = { ...resolvedCSSVars, ...cssVars };
    }
    return { cssMap: resolvedCSSMap, cssVars: resolvedCSSVars };
  };
}
function omitTheme(theme) {
  return omitObject(theme, ["__cssMap", "__cssVar", "__breakpoints"]);
}
function omitThemeProps(props, keys = []) {
  return omitObject(props, ["size", "variant", "colorScheme", ...keys]);
}
function mergeStyle(target, ...sources) {
  return function({
    omit = [],
    pick = []
  } = {}) {
    return sources.reduce(
      (prev, source) => recursiveMergeStyle(filterStyle(prev)({ omit, pick }), source),
      target
    );
  };
}
function mergeMultiStyle(target, ...sources) {
  return function({
    omit = [],
    pick = []
  } = {}) {
    return sources.reduce(
      (prev, source) => recursiveMergeStyle(
        filterStyle(prev)({ isMulti: true, omit, pick }),
        source
      ),
      target
    );
  };
}
function recursiveMergeStyle(target, source) {
  let result = Object.assign({}, target);
  if (isObject8(source) && isObject8(target)) {
    for (const [sourceKey, sourceValue] of Object.entries(source)) {
      const targetValue = target[sourceKey];
      if (target.hasOwnProperty(sourceKey)) {
        if (!isFunction(targetValue) && !isFunction(sourceValue)) {
          result[sourceKey] = recursiveMergeStyle(
            targetValue,
            sourceValue
          );
        } else {
          result[sourceKey] = (props) => recursiveMergeStyle(
            runIfFunc2(targetValue, props),
            runIfFunc2(sourceValue, props)
          );
        }
      } else {
        Object.assign(result, { [sourceKey]: sourceValue });
      }
    }
  } else {
    result = source;
  }
  return result;
}
function filterStyle(target) {
  return function({ isMulti = false, omit, pick }) {
    if (!isObject8(target)) return target;
    if (omit.length)
      target = internalFilterStyle(target, omit, isMulti)(omitObject);
    if (pick.length)
      target = internalFilterStyle(target, pick, isMulti)(pickObject);
    return target;
  };
}
function internalFilterStyle(target, keys, isMulti, refs = []) {
  return function(func) {
    if (!isObject8(target)) return target;
    let result = Object.assign({}, target);
    result = func(result, keys);
    Object.entries(result).forEach(([nestedKey, style]) => {
      const newKeys = keys.filter((key) => key !== nestedKey);
      const newRefs = [...refs, nestedKey];
      if (!onValidFilterStyleKey(newRefs, isMulti)) return;
      if (isFunction(style)) {
        result[nestedKey] = (props) => internalFilterStyle(style(props), newKeys, isMulti, newRefs)(func);
      } else {
        if (func === omitObject || Object.keys(style).some((key) => newKeys.includes(key))) {
          result[nestedKey] = internalFilterStyle(
            style,
            newKeys,
            isMulti,
            newRefs
          )(func);
        } else {
          result[nestedKey] = merge5(
            result[nestedKey],
            internalFilterStyle(style, newKeys, isMulti, newRefs)(func)
          );
        }
      }
    });
    return result;
  };
}
function onValidFilterStyleKey(keys, isMulti) {
  const rootKey = keys[0];
  switch (rootKey) {
    case "baseStyle":
      return keys.length < (isMulti ? 2 : 1);
    case "variants":
    case "sizes":
      return keys.length < (isMulti ? 3 : 2);
    default:
      return false;
  }
}
function pickStyle(target, targetKey, withProps = true) {
  const result = {};
  Object.entries(target).forEach(([key, value]) => {
    switch (key) {
      case "baseStyle":
        if (isFunction(value)) {
          result[key] = (props) => value(props)[targetKey];
        } else {
          result[key] = value[targetKey];
        }
        break;
      case "variants":
      case "sizes":
        result[key] = Object.entries(
          value
        ).reduce((prev, [key2, value2]) => {
          if (isFunction(value2)) {
            prev[key2] = (props) => value2(props)[targetKey];
          } else if (value2[targetKey]) {
            prev[key2] = value2[targetKey];
          }
          return prev;
        }, {});
        break;
      case "defaultProps":
        if (withProps) result[key] = value;
        break;
      default:
        break;
    }
  });
  return result;
}

// src/providers/theme-provider.tsx
import { jsx as jsx5, jsxs as jsxs2 } from "react/jsx-runtime";
var { localStorage: localStorage3 } = themeSchemeManager;
var ThemeProvider = ({
  children,
  config,
  storageKey,
  theme: initialTheme = {},
  themeSchemeManager: themeSchemeManager2 = localStorage3
}) => {
  const environment = useEnvironment();
  const [themeScheme, setThemeScheme] = useState2(
    themeSchemeManager2.get(config == null ? void 0 : config.initialThemeScheme)(storageKey)
  );
  const changeThemeScheme = useCallback2(
    (themeScheme2) => {
      const { getDocument } = environment;
      const doc = getDocument();
      const cleanup = (config == null ? void 0 : config.disableTransitionOnChange) ? preventTransition(environment) : void 0;
      if (doc) doc.documentElement.dataset.theme = themeScheme2;
      cleanup == null ? void 0 : cleanup();
      setThemeScheme(themeScheme2);
      themeSchemeManager2.set(themeScheme2)(storageKey);
    },
    [config, environment, themeSchemeManager2, storageKey]
  );
  const theme = useMemo5(
    () => transformTheme(initialTheme, config),
    [initialTheme, config]
  );
  useEffect2(() => {
    const themeScheme2 = themeSchemeManager2.get()(storageKey);
    if (themeScheme2) changeThemeScheme(themeScheme2);
  }, [changeThemeScheme, themeSchemeManager2, storageKey]);
  return /* @__PURE__ */ jsxs2(EmotionThemeProvider, { theme: { changeThemeScheme, themeScheme, ...theme }, children: [
    /* @__PURE__ */ jsx5(CSSVars, {}),
    children
  ] });
};
var CSSVars = () => {
  return /* @__PURE__ */ jsx5(
    Global,
    {
      styles: ({ __cssVars }) => ({
        ":host, :root, [data-mode]": __cssVars
      })
    }
  );
};
var ResetStyle = () => {
  const { colorMode } = useColorMode();
  return /* @__PURE__ */ jsx5(
    Global,
    {
      styles: (theme) => {
        const { themeScheme } = theme;
        const style = get2(theme, "styles.resetStyle", {});
        const computedStyle = runIfFunc3(style, {
          colorMode,
          theme,
          themeScheme
        });
        if (isEmptyObject2(computedStyle)) return void 0;
        return css(computedStyle)(theme);
      }
    }
  );
};
var GlobalStyle = () => {
  const { colorMode } = useColorMode();
  return /* @__PURE__ */ jsx5(
    Global,
    {
      styles: (theme) => {
        const { themeScheme } = theme;
        let style = get2(theme, "styles.globalStyle", {});
        const computedStyle = runIfFunc3(style, {
          colorMode,
          theme,
          themeScheme
        });
        if (isEmptyObject2(computedStyle)) return void 0;
        return css(computedStyle)(theme);
      }
    }
  );
};
var useTheme = () => {
  const internalTheme = useContext5(ThemeContext3);
  const theme = useMemo5(() => {
    var _a;
    const { themeScheme } = internalTheme;
    if (isUndefined4(themeScheme) || themeScheme === "base") return internalTheme;
    const nestedTheme = (_a = internalTheme.themeSchemes) == null ? void 0 : _a[themeScheme];
    if (!nestedTheme) return internalTheme;
    return merge6(internalTheme, nestedTheme);
  }, [internalTheme]);
  const value = useMemo5(() => {
    const { changeThemeScheme, themeScheme } = internalTheme;
    return { changeThemeScheme, internalTheme, theme, themeScheme };
  }, [theme, internalTheme]);
  return value;
};

// src/components/use-component-style.tsx
function getColorModeStyles(value, modifierStyles, props) {
  return function({ isMulti = false, selectors = [] }) {
    const [lightValue, darkValue] = value;
    const lightStyles = getModifierStyles(
      lightValue,
      modifierStyles,
      props
    )({ isMulti, selectors: [...selectors, pseudos._light] });
    const darkStyles = getModifierStyles(
      darkValue,
      modifierStyles,
      props
    )({ isMulti, selectors: [...selectors, pseudos._dark] });
    return merge7(lightStyles, darkStyles);
  };
}
function getResponsiveFinalQuery(queries2, breakpoints, isDown) {
  const filteredQueries = queries2.filter(
    ({ breakpoint }) => breakpoint !== "base" && breakpoints.includes(breakpoint)
  );
  const finalQuery = filteredQueries.sort(
    (a, b) => {
      var _a, _b, _c, _d;
      return isDown ? ((_a = a.maxW) != null ? _a : 0) - ((_b = b.maxW) != null ? _b : 0) : ((_c = b.minW) != null ? _c : 0) - ((_d = a.minW) != null ? _d : 0);
    }
  )[0];
  return finalQuery;
}
function getResponsiveNextQuery(value, queries2, index) {
  let nextIndex = index + 1;
  let nextQuery;
  while (nextIndex < queries2.length) {
    const query = queries2[nextIndex];
    if (value[query.breakpoint]) {
      const targetIndex = nextIndex - 1;
      nextQuery = queries2[targetIndex];
      break;
    }
    nextIndex += 1;
  }
  return nextQuery;
}
function getResponsiveStyles(value, modifierStyles, props) {
  return function({ isMulti = false, selectors = [] }) {
    var _a, _b, _c;
    const breakpoints = keysFormObject(value);
    if (breakpoints.length === 1 && "base" in value) {
      return getStyles(
        modifierStyles[value.base],
        props
      )({ isMulti });
    } else {
      const { queries: queries2 = [] } = (_a = props.theme.__breakpoints) != null ? _a : {};
      const { direction = "down", identifier } = (_c = (_b = props.theme.__config) == null ? void 0 : _b.breakpoint) != null ? _c : {};
      const isDown = direction !== "up";
      const finalQuery = getResponsiveFinalQuery(queries2, breakpoints, isDown);
      let hasBaseStyles = false;
      return queries2.reduce(
        (prev, { breakpoint, maxW, maxWQuery, minW, minWQuery }, index) => {
          const modifier = value[breakpoint];
          const isFinal = breakpoint === (finalQuery == null ? void 0 : finalQuery.breakpoint);
          if (breakpoint === "base") return prev;
          if (!modifier) return prev;
          if (!hasBaseStyles) {
            const baseModifier = value.base;
            const prevQuery = queries2[index - 1];
            const query2 = prevQuery == null ? void 0 : prevQuery[isDown ? "minWQuery" : "maxWQuery"];
            const styles3 = getModifierStyles(
              baseModifier,
              modifierStyles,
              props
            )({ isMulti, selectors: [...selectors, query2] });
            prev = merge7(prev, styles3);
            hasBaseStyles = true;
          }
          let query = isDown ? maxWQuery : minWQuery;
          if (!isFinal) {
            const nextQuery = getResponsiveNextQuery(value, queries2, index);
            minW = isDown ? nextQuery == null ? void 0 : nextQuery.minW : minW;
            maxW = isDown ? maxW : nextQuery == null ? void 0 : nextQuery.maxW;
            query = createQuery(minW, maxW, identifier);
          }
          const styles2 = getModifierStyles(
            modifier,
            modifierStyles,
            props
          )({ isMulti, selectors: [...selectors, query] });
          prev = merge7(prev, styles2);
          return prev;
        },
        {}
      );
    }
  };
}
function getModifierStyles(value, modifierStyles, props) {
  return function({
    isMulti = false,
    selectors = []
  }) {
    let styles2 = {};
    if (!value) return styles2;
    if (isArray7(value)) {
      styles2 = getColorModeStyles(
        value,
        modifierStyles,
        props
      )({ isMulti, selectors });
    } else if (isObject9(value)) {
      styles2 = getResponsiveStyles(
        value,
        modifierStyles,
        props
      )({ isMulti, selectors });
    } else {
      styles2 = getStyles(
        modifierStyles[value],
        props
      )({ isMulti, selectors });
    }
    return styles2;
  };
}
function getSelectorStyles(selectors, style) {
  return selectors.reduceRight(
    (prev, key) => key ? { [key]: prev } : prev,
    style
  );
}
function getStyles(stylesOrFunc, props) {
  return function({
    isMulti = false,
    selectors = []
  }) {
    const styles2 = runIfFunc4(stylesOrFunc, props);
    if (isMulti) {
      return Object.fromEntries(
        Object.entries(styles2 != null ? styles2 : {}).map(
          ([name, styleOrFunc]) => {
            const style = runIfFunc4(styleOrFunc, props);
            if (selectors.length) {
              return [name, getSelectorStyles(selectors, style)];
            } else {
              return [name, style];
            }
          }
        )
      );
    } else if (selectors.length) {
      return getSelectorStyles(selectors, styles2);
    } else {
      return styles2;
    }
  };
}
function mergeProps(props, defaultProps, overrideProps) {
  if (defaultProps) props = merge7(defaultProps, props);
  if (overrideProps) props = runIfFunc4(overrideProps, props);
  return props;
}
function useStyles(name, props, { isMulti, isProcessSkip: isProcessSkip2, styles: styles2 = {} } = {}) {
  const { theme, themeScheme } = useTheme();
  const { colorMode } = useColorMode();
  const propsRef = useRef2({});
  const stylesRef = useRef2(isProcessSkip2 ? styles2 : {});
  if (!isProcessSkip2) {
    const componentStyle = get3(
      theme,
      `components.${name}`
    );
    props = filterUndefined2(props);
    if (componentStyle) {
      const { baseStyle, sizes, variants, defaultProps, overrideProps } = componentStyle;
      props = mergeProps(props, defaultProps, overrideProps);
      const { colorScheme: _colorScheme, size, variant } = props;
      const colorScheme = isArray7(_colorScheme) ? getColorModeValue(_colorScheme[0], _colorScheme[1])(colorMode) : _colorScheme;
      const computedProps = { ...props, colorScheme };
      const resolvedProps = omitObject2(computedProps, ["children"]);
      let styles3 = {};
      if (baseStyle) {
        styles3 = getStyles(baseStyle, {
          colorMode,
          theme,
          themeScheme,
          ...resolvedProps
        })({ isMulti });
      }
      if (sizes) {
        const sizeStyles = getModifierStyles(size, sizes, {
          colorMode,
          theme,
          themeScheme,
          ...resolvedProps
        })({ isMulti });
        styles3 = merge7(styles3, sizeStyles);
      }
      if (variants) {
        const variantStyles = getModifierStyles(variant, variants, {
          colorMode,
          theme,
          themeScheme,
          ...resolvedProps
        })({ isMulti });
        styles3 = merge7(styles3, variantStyles);
      }
      const isStylesEqual = isEqual(stylesRef.current, styles3);
      if (!isStylesEqual) stylesRef.current = styles3;
    }
  }
  const isPropsEqual = isEqual(propsRef.current, props);
  if (!isPropsEqual) propsRef.current = props;
  return [stylesRef.current, propsRef.current];
}
function useComponentStyle(name, props, options) {
  return useStyles(name, props, options);
}
function useComponentMultiStyle(name, props, options) {
  return useStyles(name, props, { isMulti: true, ...options });
}

// src/styled.ts
import createStyled from "@emotion/styled";
import {
  assignAfter,
  filterObject,
  filterUndefined as filterUndefined3,
  interopDefault,
  runIfFunc as runIfFunc5
} from "@yamada-ui/utils";
import { createElement, forwardRef as forwardRef3 } from "react";
var emotionStyled = interopDefault(createStyled);
var styleProps = { ...styles, ...pseudos };
function toCSSObject({
  baseStyle,
  disableStyleProp
}) {
  return function(props) {
    const { css: customCSS, sx, theme, __css, ...rest } = props;
    const propsCSS = filterObject(
      rest,
      (prop) => prop in styleProps
    );
    const baseCSS = runIfFunc5(baseStyle, props);
    const computedCSS = css(
      assignAfter({}, __css, baseCSS, filterUndefined3(propsCSS), sx)
    )(theme, disableStyleProp);
    return customCSS ? [computedCSS, customCSS] : computedCSS;
  };
}
function styled(el, { baseStyle, disableStyleProp, ...styledOptions } = {}) {
  if (!styledOptions.shouldForwardProp)
    styledOptions.shouldForwardProp = shouldForwardProp(disableStyleProp);
  const CSSObject = toCSSObject({ baseStyle, disableStyleProp });
  const Component = emotionStyled(
    el,
    styledOptions
  )(CSSObject);
  const UIComponent = forwardRef3((props, ref) => {
    const { colorMode, forced } = useColorMode();
    return createElement(Component, {
      ref,
      "data-mode": forced ? colorMode : void 0,
      ...props
    });
  });
  UIComponent.displayName = "UIComponent";
  return UIComponent;
}

// src/factory.ts
function factory() {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(styled, {
    apply: (_target, _thisArg, [el, options]) => {
      return styled(el, options);
    },
    get: (_target, el) => {
      if (!cache.has(el)) cache.set(el, styled(el));
      return cache.get(el);
    }
  });
}
var ui = factory();
export {
  COLOR_MODE_STORAGE_KEY,
  CSSVars,
  ColorModeContext,
  ColorModeProvider,
  ColorModeScript,
  EnvironmentProvider,
  GlobalStyle,
  ResetStyle,
  THEME_SCHEME_STORAGE_KEY,
  ThemeProvider,
  ThemeSchemeScript,
  analyzeBreakpoints,
  animation,
  animationProperties,
  atRuleProperties,
  atRuleSelectors,
  atRuleStyles,
  atRules,
  attributeProperties,
  attributeSelectors,
  attributes,
  blurProperties,
  borderProperties,
  colorModeManager,
  colorProperties,
  createColorModeManager,
  createQuery,
  createThemeSchemeManager,
  createVars,
  css,
  defaultEnvironment,
  fontProperties,
  forwardRef2 as forwardRef,
  getCSS,
  getColorModeScript,
  getColorModeValue,
  getCreateThemeVars,
  getMinMaxQuery,
  getThemeSchemeScript,
  getVar,
  gradient,
  gradientProperties,
  groupAttributeProperties,
  groupAttributeSelectors,
  groupAttributes,
  keyframes,
  layoutStyleProperties,
  memo2 as memo,
  mergeMultiStyle,
  mergeStyle,
  mergeVars,
  mode,
  omitThemeProps,
  peerAttributeProperties,
  peerAttributeSelectors,
  peerAttributes,
  pickStyle,
  processSkipProperties,
  pseudoClassProperties,
  pseudoClassSelectors,
  pseudoClasses,
  pseudoElementProperties,
  pseudoElementSelectors,
  pseudoElements,
  pseudoProperties,
  pseudoSelectors,
  pseudoStyles,
  pseudos,
  radiusProperties,
  shadowProperties,
  shorthandStyles,
  shouldForwardProp,
  sizeProperties,
  spaceProperties,
  standardStyles,
  styleProperties,
  styled,
  styles,
  themeSchemeManager,
  toCSSObject,
  transformTheme,
  transforms,
  transitionProperties,
  ui,
  uiStyles,
  useCSS,
  useColorMode,
  useColorModeValue,
  useComponentMultiStyle,
  useComponentStyle,
  useCreateVars,
  useEnvironment,
  useSystemColorMode,
  useTheme,
  zIndexProperties
};
//# sourceMappingURL=index.mjs.map