import {
  isNumber,
  isObject,
  isString
} from "./chunk-QWVYBC6R.mjs";

// src/react.tsx
import * as React from "react";
function createContext2({
  name,
  defaultValue,
  errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
  strict = true
} = {}) {
  const Context = React.createContext(defaultValue);
  Context.displayName = name;
  const useContext2 = () => {
    const context = React.useContext(Context);
    if (!context && strict) {
      const error = new Error(errorMessage);
      error.name = "ContextError";
      Error.captureStackTrace(error, useContext2);
      throw error;
    }
    return context;
  };
  return [Context.Provider, useContext2, Context];
}
var useSafeLayoutEffect = Boolean(globalThis.document) ? React.useLayoutEffect : React.useEffect;
function useUnmountEffect(callback) {
  return React.useEffect(() => () => callback(), []);
}
function useIsMounted({
  delay = 0,
  rerender = false
} = {}) {
  const isMountedRef = React.useRef(false);
  const [isMounted, setIsMounted] = React.useState(false);
  useSafeLayoutEffect(() => {
    isMountedRef.current = true;
    let timeoutId = null;
    if (rerender) {
      if (delay > 0) {
        timeoutId = setTimeout(() => setIsMounted(true), delay);
      } else {
        setIsMounted(true);
      }
    }
    return () => {
      isMountedRef.current = false;
      if (rerender) setIsMounted(false);
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, [delay, rerender]);
  return [React.useCallback(() => isMountedRef.current, []), isMounted];
}
function getValidChildren(children) {
  return React.Children.toArray(children).filter(
    (child) => React.isValidElement(child)
  );
}
function isValidElement2(child) {
  return React.isValidElement(child) || isString(child) || isNumber(child);
}
function isSomeElement(child, type) {
  var _a, _b;
  if (child.type === type) return true;
  if (!!child.__ui__ && !!type.__ui__) {
    if (child.__ui__ === type.__ui__) return true;
  }
  const payload = child.type._payload;
  if (!!((_a = payload == null ? void 0 : payload.value) == null ? void 0 : _a.__ui__) && !!type.__ui__) {
    if (((_b = payload == null ? void 0 : payload.value) == null ? void 0 : _b.__ui__) === type.__ui__) return true;
  }
  return false;
}
function findChild(children, ...types) {
  const child = children.find(
    (child2) => types.some((type) => isSomeElement(child2, type))
  );
  return child;
}
function findChildren(children, ...types) {
  const child = children.find(
    (child2) => types.some((type) => isSomeElement(child2, type))
  );
  if (child) {
    return children.sort((a, b) => {
      if (types.some((type) => isSomeElement(a, type))) {
        return -1;
      } else if (types.some((type) => isSomeElement(b, type))) {
        return 1;
      } else {
        return 0;
      }
    });
  } else {
    return [void 0, ...children];
  }
}
function includesChildren(children, ...types) {
  return children.some((child) => {
    if (types.some((type) => isSomeElement(child, type))) return true;
    const children2 = getValidChildren(child.props.children);
    return children2.length ? includesChildren(children2, ...types) : false;
  });
}
function omitChildren(children, ...types) {
  return children.filter(
    (child) => types.every((type) => !isSomeElement(child, type))
  );
}
function pickChildren(children, ...types) {
  return children.filter(
    (child) => types.every((type) => isSomeElement(child, type))
  );
}
function cx(...classNames) {
  return classNames.filter(Boolean).join(" ");
}
function isRefObject(val) {
  return isObject(val) && "current" in val;
}
function assignRef(ref, value) {
  if (ref == null) return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return function(node) {
    return refs.forEach((ref) => {
      assignRef(ref, node);
    });
  };
}
function useMergeRefs(...refs) {
  return React.useMemo(() => mergeRefs(...refs), [refs]);
}
function useCallbackRef(callback, deps = []) {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useCallback(
    (...args) => {
      var _a;
      return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
}
function useUpdateEffect(callback, deps) {
  const renderCycleRef = React.useRef(false);
  const effectCycleRef = React.useRef(false);
  React.useEffect(() => {
    const mounted = renderCycleRef.current;
    const run = mounted && effectCycleRef.current;
    if (run) return callback();
    effectCycleRef.current = true;
  }, deps);
  React.useEffect(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
}
function useAsync(func, deps = []) {
  const [state, callback] = useAsyncFunc(func, deps, { loading: true });
  React.useEffect(() => {
    callback();
  }, [callback]);
  return state;
}
function useAsyncFunc(func, deps = [], initialState = { loading: false }) {
  const lastCallId = React.useRef(0);
  const [isMounted] = useIsMounted();
  const [state, setState] = React.useState(initialState);
  const callback = React.useCallback(
    (...args) => {
      const callId = ++lastCallId.current;
      if (!state.loading)
        setState((prevState) => ({ ...prevState, loading: true }));
      return func(...args).then(
        (value) => {
          if (isMounted() && callId === lastCallId.current)
            setState({ loading: false, value });
          return value;
        },
        (error) => {
          if (isMounted() && callId === lastCallId.current)
            setState({ error, loading: false });
          return error;
        }
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  return [state, callback];
}
function useAsyncRetry(func, deps = []) {
  const [attempt, setAttempt] = React.useState(0);
  const state = useAsync(func, [...deps, attempt]);
  const stateLoading = state.loading;
  const retry = React.useCallback(() => {
    if (stateLoading) return;
    setAttempt((currentAttempt) => currentAttempt + 1);
  }, [...deps, stateLoading]);
  return { ...state, retry };
}
var createIdCounter = 0;
function createId(prefix) {
  return `${prefix}-${++createIdCounter}-${(/* @__PURE__ */ new Date()).getTime()}`;
}

export {
  createContext2 as createContext,
  useSafeLayoutEffect,
  useUnmountEffect,
  useIsMounted,
  getValidChildren,
  isValidElement2 as isValidElement,
  isSomeElement,
  findChild,
  findChildren,
  includesChildren,
  omitChildren,
  pickChildren,
  cx,
  isRefObject,
  assignRef,
  mergeRefs,
  useMergeRefs,
  useCallbackRef,
  useUpdateEffect,
  useAsync,
  useAsyncFunc,
  useAsyncRetry,
  createId
};
//# sourceMappingURL=chunk-NVC6I45P.mjs.map