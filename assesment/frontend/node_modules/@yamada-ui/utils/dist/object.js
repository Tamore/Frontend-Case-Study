"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/object.ts
var object_exports = {};
__export(object_exports, {
  assignAfter: () => assignAfter,
  filterObject: () => filterObject,
  filterUndefined: () => filterUndefined,
  flattenObject: () => flattenObject,
  getMemoizedObject: () => getMemoizedObject,
  getObject: () => getObject,
  keysFormObject: () => keysFormObject,
  memoizeObject: () => memoizeObject,
  merge: () => merge,
  objectFromEntries: () => objectFromEntries,
  omitObject: () => omitObject,
  pickObject: () => pickObject,
  replaceObject: () => replaceObject,
  splitObject: () => splitObject
});
module.exports = __toCommonJS(object_exports);

// src/assertion.ts
function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function") && !isArray(value);
}
function isArray(value) {
  return Array.isArray(value);
}
function isFunction(value) {
  return typeof value === "function";
}

// src/object.ts
function omitObjectHelper(obj, path) {
  if (!path.length) return obj;
  const [primaryKey, ...restKeys] = path;
  if (restKeys.length === 0 && primaryKey && primaryKey in obj) {
    const { [primaryKey]: _, ...rest } = obj;
    return rest;
  }
  if (primaryKey && obj[primaryKey] && isObject(obj[primaryKey])) {
    return {
      ...obj,
      [primaryKey]: omitObjectHelper(obj[primaryKey], restKeys)
    };
  }
  return obj;
}
function omitObject(obj, keys) {
  return keys.reduce((prev, key) => {
    const path = isString(key) ? key.split(".") : [];
    return omitObjectHelper(prev, path);
  }, obj);
}
function pickObject(obj, keys, fallbackValue = "__fallback") {
  return keys.reduce((prev, key) => {
    const path = isString(key) ? key.split(".") : [];
    if (!path.length) return prev;
    const value = getMemoizedObject(obj, key, fallbackValue);
    if (value === fallbackValue) return prev;
    prev = merge(
      prev,
      path.reduceRight(
        (prev2, key2) => ({ [key2]: key2 === path.at(-1) ? value : prev2 }),
        {}
      )
    );
    return prev;
  }, {});
}
function splitObject(obj, keys) {
  const picked = {};
  const omitted = {};
  for (const [key, value] of Object.entries(obj)) {
    if (keys.includes(key)) {
      picked[key] = value;
    } else {
      omitted[key] = value;
    }
  }
  return [picked, omitted];
}
function filterObject(obj, func) {
  const result = {};
  Object.entries(obj).forEach(([key, value]) => {
    const shouldPass = func(key, value, obj);
    if (shouldPass) result[key] = value;
  });
  return result;
}
function filterUndefined(obj) {
  return filterObject(obj, (_, val) => val !== null && val !== void 0);
}
function merge(target, source, mergeArray = false) {
  let result = Object.assign({}, target);
  if (isObject(source)) {
    if (isObject(target)) {
      for (const [sourceKey, sourceValue] of Object.entries(source)) {
        const targetValue = target[sourceKey];
        if (mergeArray && isArray(sourceValue) && isArray(targetValue)) {
          result[sourceKey] = targetValue.concat(...sourceValue);
        } else if (!isFunction(sourceValue) && isObject(sourceValue) && target.hasOwnProperty(sourceKey)) {
          result[sourceKey] = merge(targetValue, sourceValue, mergeArray);
        } else {
          Object.assign(result, { [sourceKey]: sourceValue });
        }
      }
    } else {
      result = source;
    }
  }
  return result;
}
function flattenObject(obj, { maxDepth, omitKeys, separator, shouldProcess } = {}) {
  maxDepth != null ? maxDepth : maxDepth = Infinity;
  omitKeys != null ? omitKeys : omitKeys = [];
  separator != null ? separator : separator = ".";
  if (!isObject(obj) && !isArray(obj) || !maxDepth) return obj;
  return Object.entries(obj).reduce((result, [key, value]) => {
    if (isObject(value) && !Object.keys(value).some((key2) => omitKeys.includes(key2)) && (!shouldProcess || shouldProcess(value))) {
      Object.entries(
        flattenObject(value, {
          maxDepth: maxDepth - 1,
          omitKeys,
          separator,
          shouldProcess
        })
      ).forEach(([childKey, childValue]) => {
        result[`${key}${separator}${childKey}`] = childValue;
      });
    } else {
      result[key] = value;
    }
    return result;
  }, {});
}
function objectFromEntries(entries) {
  return entries.reduce((result, [key, value]) => {
    result[key] = value;
    return result;
  }, {});
}
function keysFormObject(obj) {
  return Object.keys(obj);
}
function replaceObject(objOrArray, callBack) {
  if (isArray(objOrArray)) {
    return objOrArray.map(callBack);
  } else if (isObject(objOrArray)) {
    return Object.entries(objOrArray).reduce((obj, [key, value]) => {
      obj[key] = callBack(value);
      return obj;
    }, {});
  } else {
    return callBack(objOrArray);
  }
}
function getObject(obj, path, fallback, i) {
  const keys = isString(path) ? path.split(/\[(.*?)\]|\./).filter(Boolean) : [path];
  for (i = 0; i < keys.length; i += 1) {
    if (!obj) break;
    const key = keys[i];
    obj = key ? obj[key] : void 0;
  }
  return obj === void 0 ? fallback : obj;
}
function memoizeObject(func) {
  const cache = /* @__PURE__ */ new WeakMap();
  function memoizedFunc(obj, path, fallback, i) {
    if (isUndefined(obj)) return func(obj, path, fallback);
    if (!cache.has(obj)) cache.set(obj, /* @__PURE__ */ new Map());
    const map = cache.get(obj);
    if (map.has(path)) return map.get(path);
    const value = func(obj, path, fallback, i);
    map.set(path, value);
    return value;
  }
  return memoizedFunc;
}
var getMemoizedObject = memoizeObject(getObject);
function assignAfter(target, ...sources) {
  const result = { ...target };
  for (const nextSource of sources) {
    if (nextSource == null) continue;
    for (const nextKey in nextSource) {
      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) continue;
      if (nextKey in result) delete result[nextKey];
      result[nextKey] = nextSource[nextKey];
    }
  }
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assignAfter,
  filterObject,
  filterUndefined,
  flattenObject,
  getMemoizedObject,
  getObject,
  keysFormObject,
  memoizeObject,
  merge,
  objectFromEntries,
  omitObject,
  pickObject,
  replaceObject,
  splitObject
});
//# sourceMappingURL=object.js.map