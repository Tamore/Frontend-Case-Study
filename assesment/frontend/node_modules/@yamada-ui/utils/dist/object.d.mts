import { Dict } from './index.types.mjs';

declare function omitObject<Y extends Dict, M extends keyof Y = keyof Y, D = any>(obj: Y, keys: M[] | readonly M[]): D extends unknown ? Omit<Y, M> : D;
declare function pickObject<Y extends Dict, M extends keyof Y = keyof Y, D = any>(obj: Y, keys: M[] | readonly M[], fallbackValue?: string): D extends unknown ? { [H in M]: Y[H]; } : D;
declare function splitObject<Y extends Dict, M extends keyof Y>(obj: Y, keys: M[] | readonly M[]): [{ [P in M]: Y[P]; }, Omit<Y, M>];
declare function filterObject<Y extends Dict, M extends Dict>(obj: Y, func: (key: keyof Y, value: Y[keyof Y], obj: Y) => boolean): M;
declare function filterUndefined<Y extends Dict>(obj: Y): Y;
declare function merge<Y extends Dict>(target: any, source: any, mergeArray?: boolean): Y;
interface FlattenObjectOptions {
    maxDepth?: number;
    omitKeys?: string[];
    separator?: string;
    shouldProcess?: (obj: any) => boolean;
}
declare function flattenObject<Y extends Dict>(obj: any, { maxDepth, omitKeys, separator, shouldProcess }?: FlattenObjectOptions): Y;
declare function objectFromEntries<Y extends Dict>(entries: any[][]): Y;
declare function keysFormObject<Y extends object>(obj: Y): (keyof Y)[];
declare function replaceObject<Y = any>(objOrArray: Y, callBack: (value: any) => any): Y;
declare function getObject(obj: Dict | undefined, path: number | string, fallback?: any, i?: number): any;
declare function memoizeObject(func: typeof getObject): <Y>(obj: Dict, path: number | string, fallback?: any, i?: number) => Y;
declare const getMemoizedObject: <Y>(obj: Dict, path: number | string, fallback?: any, i?: number) => Y;
declare function assignAfter(target: {
    [key: string]: any;
}, ...sources: any[]): {
    [key: string]: unknown;
};

export { type FlattenObjectOptions, assignAfter, filterObject, filterUndefined, flattenObject, getMemoizedObject, getObject, keysFormObject, memoizeObject, merge, objectFromEntries, omitObject, pickObject, replaceObject, splitObject };
