"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  COLOR_SCHEMES: () => COLOR_SCHEMES,
  SEMANTIC_COLOR_SCHEMES: () => SEMANTIC_COLOR_SCHEMES,
  TONES: () => TONES,
  addDomEvent: () => addDomEvent,
  addPointerEvent: () => addPointerEvent,
  alphaToHex: () => alphaToHex,
  antonym: () => antonym,
  ariaAttr: () => ariaAttr,
  assignAfter: () => assignAfter,
  assignRef: () => assignRef,
  calc: () => calc,
  calcFormat: () => calcFormat,
  cast: () => cast,
  clampNumber: () => clampNumber,
  convertColor: () => convertColor,
  countDecimal: () => countDecimal,
  createContext: () => createContext2,
  createId: () => createId,
  createdDom: () => createdDom,
  cx: () => cx,
  darkenColor: () => darkenColor,
  dataAttr: () => dataAttr,
  escape: () => escape,
  filterEmpty: () => filterEmpty,
  filterObject: () => filterObject,
  filterUndefined: () => filterUndefined,
  findChild: () => findChild,
  findChildren: () => findChildren,
  flattenObject: () => flattenObject,
  funcAll: () => funcAll,
  getActiveElement: () => getActiveElement,
  getAllFocusable: () => getAllFocusable,
  getAlpha: () => getAlpha,
  getColor: () => getColor,
  getEventPoint: () => getEventPoint,
  getEventRelatedTarget: () => getEventRelatedTarget,
  getEventWindow: () => getEventWindow,
  getMemoizedObject: () => getMemoizedObject,
  getObject: () => getObject,
  getOwnerDocument: () => getOwnerDocument,
  getOwnerWindow: () => getOwnerWindow,
  getPlatform: () => getPlatform,
  getPx: () => getPx,
  getValidChildren: () => getValidChildren,
  handlerAll: () => handlerAll,
  hasNegativeTabIndex: () => hasNegativeTabIndex,
  hasTabIndex: () => hasTabIndex,
  hslaTo: () => hslaTo,
  hsvTo: () => hsvTo,
  includesChildren: () => includesChildren,
  interopDefault: () => interopDefault,
  is: () => is,
  isAccessible: () => isAccessible,
  isActiveElement: () => isActiveElement,
  isApple: () => isApple,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isContains: () => isContains,
  isContentEditable: () => isContentEditable,
  isDark: () => isDark,
  isDisabled: () => isDisabled,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEmptyObject: () => isEmptyObject,
  isFocusable: () => isFocusable,
  isFunction: () => isFunction,
  isGray: () => isGray,
  isHTMLElement: () => isHTMLElement,
  isHidden: () => isHidden,
  isLight: () => isLight,
  isMac: () => isMac,
  isMouseEvent: () => isMouseEvent,
  isMultiTouchEvent: () => isMultiTouchEvent,
  isNotNumber: () => isNotNumber,
  isNull: () => isNull,
  isNumber: () => isNumber,
  isNumeric: () => isNumeric,
  isObject: () => isObject,
  isRefObject: () => isRefObject,
  isSafari: () => isSafari,
  isSomeElement: () => isSomeElement,
  isString: () => isString,
  isTabbable: () => isTabbable,
  isTone: () => isTone,
  isTouchDevice: () => isTouchDevice,
  isTouchEvent: () => isTouchEvent,
  isUndefined: () => isUndefined,
  isUnit: () => isUnit,
  isValidElement: () => isValidElement2,
  keysFormObject: () => keysFormObject,
  lightenColor: () => lightenColor,
  memoizeObject: () => memoizeObject,
  merge: () => merge,
  mergeRefs: () => mergeRefs,
  noop: () => noop,
  objectFromEntries: () => objectFromEntries,
  omitChildren: () => omitChildren,
  omitObject: () => omitObject,
  parseToHsla: () => parseToHsla2,
  parseToHsv: () => parseToHsv,
  parseToRgba: () => parseToRgba2,
  percentToValue: () => percentToValue,
  pickChildren: () => pickChildren,
  pickObject: () => pickObject,
  platform: () => platform,
  pointFromMouse: () => pointFromMouse,
  pointFromTouch: () => pointFromTouch,
  randomColor: () => randomColor,
  replaceObject: () => replaceObject,
  rgbaTo: () => rgbaTo,
  roundNumberToStep: () => roundNumberToStep,
  runIfFunc: () => runIfFunc,
  sameColor: () => sameColor,
  shadeColor: () => shadeColor,
  splitObject: () => splitObject,
  tintColor: () => tintColor,
  toCamelCase: () => toCamelCase,
  toKebabCase: () => toKebabCase,
  toNumber: () => toNumber,
  toPascalCase: () => toPascalCase,
  toPrecision: () => toPrecision,
  toTitleCase: () => toTitleCase,
  transformSize: () => transformSize,
  transparentizeColor: () => transparentizeColor,
  useAsync: () => useAsync,
  useAsyncFunc: () => useAsyncFunc,
  useAsyncRetry: () => useAsyncRetry,
  useCallbackRef: () => useCallbackRef,
  useIsMounted: () => useIsMounted,
  useMergeRefs: () => useMergeRefs,
  useSafeLayoutEffect: () => useSafeLayoutEffect,
  useUnmountEffect: () => useUnmountEffect,
  useUpdateEffect: () => useUpdateEffect,
  valueToPercent: () => valueToPercent,
  vendor: () => vendor
});
module.exports = __toCommonJS(src_exports);

// src/array.ts
function filterEmpty(array) {
  return array.filter((value) => value != null);
}

// src/assertion.ts
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
}
function isNumber(value) {
  return typeof value === "number";
}
function isNotNumber(value) {
  return typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value);
}
function isNumeric(value) {
  return !isNaN(parseFloat(String(value))) && isFinite(Number(value)) && /^-?\d*\.?\d+$/.test(String(value));
}
function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isNull(value) {
  return value === null;
}
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function") && !isArray(value);
}
function isArray(value) {
  return Array.isArray(value);
}
function isEmpty(value) {
  return !isArray(value) || !value.length || value.every((v) => v == null);
}
function isEmptyObject(value) {
  return isObject(value) && !Object.keys(value).length;
}
function isFunction(value) {
  return typeof value === "function";
}
function isUnit(value) {
  return /[0-9].*(em|rem|ex|rex|cap|rcap|ch|rch|ic|ric|lh|rlh|vw|svw|lvw|dvw|vh|svh|lvh|dvh|vi|svi|lvi|dvi|vb|svb|lvb|dvb|vmin|svmin|lvmin|dvmin|vmax|svmax|lvmax|dvmax|cm|mm|Q|in|pc|pt|px|%|cqw|cqh|cqi|cqb|cqmin|cqmax)$/.test(
    value
  );
}
function cast(value) {
  return value;
}

// src/calc.ts
function toExpression(operator, ...args) {
  return args.join(` ${operator} `).replace(/calc/g, "");
}
function add(...args) {
  return `calc(${toExpression("+", ...args)})`;
}
function subtract(...args) {
  return `calc(${toExpression("-", ...args)})`;
}
function multiply(...args) {
  return `calc(${toExpression("*", ...args)})`;
}
function divide(...args) {
  return `calc(${toExpression("/", ...args)})`;
}
function negate(value) {
  if (!isNaN(parseFloat(value.toString())))
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  return multiply(value, -1);
}
var calc = Object.assign(
  (x) => ({
    add: (...args) => calc(add(x, ...args)),
    divide: (...args) => calc(divide(x, ...args)),
    multiply: (...args) => calc(multiply(x, ...args)),
    negate: () => calc(negate(x)),
    subtract: (...args) => calc(subtract(x, ...args)),
    toString: () => x.toString()
  }),
  {
    add,
    divide,
    multiply,
    negate,
    subtract
  }
);

// src/color.ts
var c = __toESM(require("color2k"));

// src/object.ts
function omitObjectHelper(obj, path) {
  if (!path.length) return obj;
  const [primaryKey, ...restKeys] = path;
  if (restKeys.length === 0 && primaryKey && primaryKey in obj) {
    const { [primaryKey]: _, ...rest } = obj;
    return rest;
  }
  if (primaryKey && obj[primaryKey] && isObject(obj[primaryKey])) {
    return {
      ...obj,
      [primaryKey]: omitObjectHelper(obj[primaryKey], restKeys)
    };
  }
  return obj;
}
function omitObject(obj, keys) {
  return keys.reduce((prev, key) => {
    const path = isString(key) ? key.split(".") : [];
    return omitObjectHelper(prev, path);
  }, obj);
}
function pickObject(obj, keys, fallbackValue = "__fallback") {
  return keys.reduce((prev, key) => {
    const path = isString(key) ? key.split(".") : [];
    if (!path.length) return prev;
    const value = getMemoizedObject(obj, key, fallbackValue);
    if (value === fallbackValue) return prev;
    prev = merge(
      prev,
      path.reduceRight(
        (prev2, key2) => ({ [key2]: key2 === path.at(-1) ? value : prev2 }),
        {}
      )
    );
    return prev;
  }, {});
}
function splitObject(obj, keys) {
  const picked = {};
  const omitted = {};
  for (const [key, value] of Object.entries(obj)) {
    if (keys.includes(key)) {
      picked[key] = value;
    } else {
      omitted[key] = value;
    }
  }
  return [picked, omitted];
}
function filterObject(obj, func) {
  const result = {};
  Object.entries(obj).forEach(([key, value]) => {
    const shouldPass = func(key, value, obj);
    if (shouldPass) result[key] = value;
  });
  return result;
}
function filterUndefined(obj) {
  return filterObject(obj, (_, val) => val !== null && val !== void 0);
}
function merge(target, source, mergeArray = false) {
  let result = Object.assign({}, target);
  if (isObject(source)) {
    if (isObject(target)) {
      for (const [sourceKey, sourceValue] of Object.entries(source)) {
        const targetValue = target[sourceKey];
        if (mergeArray && isArray(sourceValue) && isArray(targetValue)) {
          result[sourceKey] = targetValue.concat(...sourceValue);
        } else if (!isFunction(sourceValue) && isObject(sourceValue) && target.hasOwnProperty(sourceKey)) {
          result[sourceKey] = merge(targetValue, sourceValue, mergeArray);
        } else {
          Object.assign(result, { [sourceKey]: sourceValue });
        }
      }
    } else {
      result = source;
    }
  }
  return result;
}
function flattenObject(obj, { maxDepth, omitKeys, separator, shouldProcess } = {}) {
  maxDepth != null ? maxDepth : maxDepth = Infinity;
  omitKeys != null ? omitKeys : omitKeys = [];
  separator != null ? separator : separator = ".";
  if (!isObject(obj) && !isArray(obj) || !maxDepth) return obj;
  return Object.entries(obj).reduce((result, [key, value]) => {
    if (isObject(value) && !Object.keys(value).some((key2) => omitKeys.includes(key2)) && (!shouldProcess || shouldProcess(value))) {
      Object.entries(
        flattenObject(value, {
          maxDepth: maxDepth - 1,
          omitKeys,
          separator,
          shouldProcess
        })
      ).forEach(([childKey, childValue]) => {
        result[`${key}${separator}${childKey}`] = childValue;
      });
    } else {
      result[key] = value;
    }
    return result;
  }, {});
}
function objectFromEntries(entries) {
  return entries.reduce((result, [key, value]) => {
    result[key] = value;
    return result;
  }, {});
}
function keysFormObject(obj) {
  return Object.keys(obj);
}
function replaceObject(objOrArray, callBack) {
  if (isArray(objOrArray)) {
    return objOrArray.map(callBack);
  } else if (isObject(objOrArray)) {
    return Object.entries(objOrArray).reduce((obj, [key, value]) => {
      obj[key] = callBack(value);
      return obj;
    }, {});
  } else {
    return callBack(objOrArray);
  }
}
function getObject(obj, path, fallback, i) {
  const keys = isString(path) ? path.split(/\[(.*?)\]|\./).filter(Boolean) : [path];
  for (i = 0; i < keys.length; i += 1) {
    if (!obj) break;
    const key = keys[i];
    obj = key ? obj[key] : void 0;
  }
  return obj === void 0 ? fallback : obj;
}
function memoizeObject(func) {
  const cache = /* @__PURE__ */ new WeakMap();
  function memoizedFunc(obj, path, fallback, i) {
    if (isUndefined(obj)) return func(obj, path, fallback);
    if (!cache.has(obj)) cache.set(obj, /* @__PURE__ */ new Map());
    const map = cache.get(obj);
    if (map.has(path)) return map.get(path);
    const value = func(obj, path, fallback, i);
    map.set(path, value);
    return value;
  }
  return memoizedFunc;
}
var getMemoizedObject = memoizeObject(getObject);
function assignAfter(target, ...sources) {
  const result = { ...target };
  for (const nextSource of sources) {
    if (nextSource == null) continue;
    for (const nextKey in nextSource) {
      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) continue;
      if (nextKey in result) delete result[nextKey];
      result[nextKey] = nextSource[nextKey];
    }
  }
  return result;
}

// src/color.ts
var SEMANTIC_COLOR_SCHEMES = [
  "primary",
  "secondary",
  "info",
  "success",
  "warning",
  "danger",
  "link"
];
var COLOR_SCHEMES = [
  "gray",
  "neutral",
  "red",
  "rose",
  "pink",
  "flashy",
  "orange",
  "amber",
  "yellow",
  "lime",
  "green",
  "emerald",
  "teal",
  "cyan",
  "sky",
  "blue",
  "indigo",
  "violet",
  "purple",
  "fuchsia"
];
var TONES = [
  50,
  100,
  200,
  300,
  400,
  500,
  600,
  700,
  800,
  900,
  950
];
function isGray(colorScheme) {
  return colorScheme === "gray" || colorScheme === "neutral";
}
function isAccessible(colorScheme) {
  return colorScheme === "yellow" || colorScheme === "cyan" || colorScheme === "lime";
}
function getColor(color, fallback = "#000000") {
  return function(theme = {}, colorMode = "light", breakpoint = "base") {
    var _a, _b, _c, _d, _e, _f;
    const [token, tone] = color.split(".");
    if (tone) {
      const [, relatedToken] = (_c = Object.entries((_b = (_a = theme.semantics) == null ? void 0 : _a.colorSchemes) != null ? _b : {}).find(
        ([semanticToken]) => token === semanticToken
      )) != null ? _c : [];
      if (relatedToken) color = `${relatedToken}.${tone}`;
    } else {
      const [, relatedColor] = (_f = Object.entries((_e = (_d = theme.semantics) == null ? void 0 : _d.colors) != null ? _e : {}).find(
        ([semanticToken]) => token === semanticToken
      )) != null ? _f : [];
      if (relatedColor) color = relatedColor;
    }
    const hex = getMemoizedObject(
      theme,
      `colors.${color}`,
      color
    );
    try {
      if (isArray(hex)) {
        return c.toHex(String(hex[colorMode !== "dark" ? 0 : 1]));
      } else if (isObject(hex)) {
        return c.toHex(String(hex[breakpoint]));
      } else {
        return c.toHex(String(hex));
      }
    } catch {
      try {
        return c.toHex(fallback);
      } catch {
        return "#000000";
      }
    }
  };
}
function lightenColor(color, amount) {
  return function(theme, colorMode, breakpoint) {
    const raw = getColor(color, color)(theme, colorMode, breakpoint);
    return c.toHex(c.lighten(raw, amount / 100));
  };
}
function darkenColor(color, amount) {
  return function(theme, colorMode, breakpoint) {
    const raw = getColor(color, color)(theme, colorMode, breakpoint);
    return c.toHex(c.darken(raw, amount / 100));
  };
}
function tintColor(color, amount) {
  return function(theme, colorMode, breakpoint) {
    const raw = getColor(color, color)(theme, colorMode, breakpoint);
    return c.toHex(c.mix(raw, "#fff", amount / 100));
  };
}
function shadeColor(color, amount) {
  return function(theme, colorMode, breakpoint) {
    const raw = getColor(color, color)(theme, colorMode, breakpoint);
    return c.toHex(c.mix(raw, "#000", amount / 100));
  };
}
function transparentizeColor(color, alpha) {
  return function(theme, colorMode, breakpoint) {
    const raw = getColor(color, color)(theme, colorMode, breakpoint);
    return c.transparentize(raw, 1 - alpha);
  };
}
function randomColor({
  colors,
  string
} = {}) {
  var _a, _b;
  const fallback = randomHex();
  if (string && colors) return (_a = randomColorFromList(string, colors)) != null ? _a : fallback;
  if (string && !colors) return randomColorFromString(string);
  if (colors && !string) return (_b = randomFromList(colors)) != null ? _b : fallback;
  return fallback;
}
function randomHex() {
  return `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
}
function randomColorFromString(str) {
  let hash = 0;
  if (str.length === 0) return hash.toString();
  for (let i = 0; i < str.length; i += 1) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
    hash = hash & hash;
  }
  let color = "#";
  for (let j = 0; j < 3; j += 1) {
    const value = hash >> j * 8 & 255;
    color += `00${value.toString(16)}`.substr(-2);
  }
  return color;
}
function randomColorFromList(str, list) {
  let index = 0;
  if (str.length === 0) return list[0];
  for (let i = 0; i < str.length; i += 1) {
    index = str.charCodeAt(i) + ((index << 5) - index);
    index = index & index;
  }
  index = (index % list.length + list.length) % list.length;
  return list[index];
}
function randomFromList(list) {
  return list[Math.floor(Math.random() * list.length)];
}
function getBrightness(color) {
  const [r, g, b] = c.parseToRgba(color);
  return (r * 299 + g * 587 + b * 114) / 1e3;
}
function isTone(color) {
  return function(theme, colorMode, breakpoint) {
    const raw = theme ? getColor(color)(theme, colorMode, breakpoint) : color;
    const brightness = getBrightness(raw);
    const isDark2 = brightness < 128;
    return isDark2 ? "dark" : "light";
  };
}
function isLight(color) {
  return function(theme, colorMode) {
    return isTone(color)(theme, colorMode) === "dark";
  };
}
function isDark(color) {
  return function(theme, colorMode) {
    return isTone(color)(theme, colorMode) === "light";
  };
}
function convertColor(color, fallback) {
  return function(format) {
    try {
      const isAlpha = format.endsWith("a");
      if (/^[0-9a-fA-F]{6}$/.test(color)) color = "#" + color;
      if (format.startsWith("hex")) {
        let hexa = c.toHex(color);
        if (isAlpha) {
          if (hexa.length === 7) hexa += "ff";
        } else {
          hexa = hexa.replace(/(?<=^#([0-9a-fA-F]{6}))[0-9a-fA-F]{2}$/, "");
        }
        return hexa;
      } else if (format.startsWith("hsl")) {
        let hsla2 = c.toHsla(color);
        if (!isAlpha) {
          hsla2 = hsla2.replace(/hsla/, "hsl");
          hsla2 = hsla2.replace(/,\s*\d+(\.\d+)?\)$/, ")");
        }
        return hsla2;
      } else {
        let rgba2 = c.toRgba(color);
        if (!isAlpha) {
          rgba2 = rgba2.replace(/rgba/, "rgb");
          rgba2 = rgba2.replace(/,\s*\d+(\.\d+)?\)$/, ")");
        }
        return rgba2;
      }
    } catch {
      if (fallback) return convertColor(fallback)(format);
    }
  };
}
function calcFormat(color) {
  if (color.startsWith("hsl")) {
    return color.startsWith("hsla") ? "hsla" : "hsl";
  } else if (color.startsWith("rgb")) {
    return color.startsWith("rgba") ? "rgba" : "rgb";
  } else {
    return color.length === 9 ? "hexa" : "hex";
  }
}
function getAlpha(color) {
  return c.parseToRgba(color)[3];
}
function alphaToHex(a) {
  if (0 > a) a = 0;
  if (1 < a) a = 1;
  return Math.round(a * 255).toString(16).padStart(2, "0");
}
function parseToRgba2(color, fallback) {
  try {
    if (/^[0-9a-fA-F]{6}$/.test(color)) color = "#" + color;
    return c.parseToRgba(color);
  } catch {
    if (fallback) return c.parseToRgba(fallback);
  }
}
function parseToHsla2(color, fallback) {
  try {
    if (/^[0-9a-fA-F]{6}$/.test(color)) color = "#" + color;
    return c.parseToHsla(color);
  } catch {
    if (fallback) return c.parseToHsla(fallback);
  }
}
function parseToHsv(color, fallback) {
  var _a;
  let [r, g, b, a] = (_a = parseToRgba2(color, fallback)) != null ? _a : [255, 255, 255, 1];
  r = r / 255;
  g = g / 255;
  b = b / 255;
  const [min, max] = [Math.min(r, g, b), Math.max(r, g, b)];
  const delta = max - min;
  let [h, v, s] = [0, max, max == 0 ? 0 : delta / max];
  switch (min) {
    case max:
      h = 0;
      break;
    case r:
      h = 60 * ((b - g) / delta) + 180;
      break;
    case g:
      h = 60 * ((r - b) / delta) + 300;
      break;
    case b:
      h = 60 * ((g - r) / delta) + 60;
      break;
  }
  return [h, s, v, a];
}
function rgbaTo([r, g, b, a], fallback) {
  return function(format = "hex") {
    return convertColor(c.rgba(r, g, b, a), fallback)(format);
  };
}
function hslaTo([h, s, l, a], fallback) {
  return function(format = "hex") {
    return convertColor(c.hsla(h, s, l, a), fallback)(format);
  };
}
function hsvTo([h, s, v, a], fallback) {
  return function(format = "hex") {
    h = h / 60;
    let rgb = [v, v, v];
    let i = Math.floor(h);
    let f = h - i;
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));
    switch (i) {
      case 0:
      case 6:
        rgb = [v, t, p];
        break;
      case 1:
        rgb = [q, v, p];
        break;
      case 2:
        rgb = [p, v, t];
        break;
      case 3:
        rgb = [p, q, v];
        break;
      case 4:
        rgb = [t, p, v];
        break;
      case 5:
        rgb = [v, p, q];
        break;
    }
    let color = `rgb(${rgb.map((v2) => Math.round(v2 * 255)).join(", ")})`;
    if (isNumber(a)) color = color.replace(/\)$/, `, ${a})`);
    return convertColor(color, fallback)(format);
  };
}
function sameColor(color, comparison) {
  var _a, _b;
  if (!color) return false;
  if (!comparison) return false;
  const a = (_a = parseToRgba2(color)) != null ? _a : [];
  const b = (_b = parseToRgba2(comparison)) != null ? _b : [];
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

// src/dom.ts
function createdDom() {
  var _a;
  return !!(typeof window !== "undefined" && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  ((_a = window.document) == null ? void 0 : _a.createElement));
}
function getPlatform() {
  var _a, _b;
  return (_b = (_a = navigator.userAgentData) == null ? void 0 : _a.platform) != null ? _b : navigator.platform;
}
function vendor(v) {
  return createdDom() && v.test(navigator.vendor);
}
function platform(v) {
  return createdDom() && v.test(getPlatform());
}
function isMac() {
  return platform(/^mac/i);
}
function isApple() {
  return platform(/mac|iphone|ipad|ipod/i);
}
function isSafari() {
  return isApple() && vendor(/apple/i);
}
function isElement(el) {
  return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
}
function isHTMLElement(el) {
  var _a;
  if (!isElement(el)) return false;
  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
  return el instanceof win.HTMLElement;
}
function isHidden(el) {
  if (el.parentElement && isHidden(el.parentElement)) return true;
  return el.hidden;
}
function isDisabled(el) {
  return Boolean(el.getAttribute("disabled")) || Boolean(el.getAttribute("data-disabled")) || Boolean(el.getAttribute("aria-disabled"));
}
function isVisible(el) {
  return el.offsetWidth > 0 && el.offsetHeight > 0;
}
function hasTabIndex(el) {
  return el.hasAttribute("tabindex");
}
function isContentEditable(el) {
  const value = el.getAttribute("contenteditable");
  return value !== "false" && value != null;
}
function isContains(parent, child) {
  return parent === child || (parent == null ? void 0 : parent.contains(child));
}
function getPx(value) {
  if (isNumber(value)) return value;
  if (isUndefined(value)) return 0;
  if (value.includes("px")) return parseFloat(value);
  const isBrowser = createdDom();
  let fontSize = 16;
  if (isBrowser) {
    const style = window.getComputedStyle(document.documentElement);
    const computedFontSize = parseFloat(style.fontSize);
    if (!isNaN(computedFontSize)) fontSize = computedFontSize;
  }
  return parseFloat(value) * fontSize;
}
function getEventRelatedTarget(ev) {
  var _a;
  return (_a = ev.relatedTarget) != null ? _a : ev.currentTarget.ownerDocument.activeElement;
}
function dataAttr(condition) {
  return condition ? "" : void 0;
}
function ariaAttr(condition) {
  return condition ? true : void 0;
}
var focusableElList = [
  "input:not(:disabled):not([disabled])",
  "select:not(:disabled):not([disabled])",
  "textarea:not(:disabled):not([disabled])",
  "embed",
  "iframe",
  "object",
  "a[href]",
  "area[href]",
  "button:not(:disabled):not([disabled])",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  "*[tabindex]:not([aria-disabled])",
  "*[contenteditable]"
];
var focusableElSelector = focusableElList.join();
function getAllFocusable(container) {
  const focusableEls = Array.from(
    container.querySelectorAll(focusableElSelector)
  );
  focusableEls.unshift(container);
  return focusableEls.filter((el) => isFocusable(el) && isVisible(el));
}
function isFocusable(el) {
  if (!isHTMLElement(el) || isHidden(el) || isDisabled(el)) {
    return false;
  }
  const { localName } = el;
  const focusableTags = ["input", "select", "textarea", "button"];
  if (focusableTags.includes(localName)) return true;
  const others = {
    a: () => el.hasAttribute("href"),
    audio: () => el.hasAttribute("controls"),
    video: () => el.hasAttribute("controls")
  };
  if (localName in others) return others[localName]();
  if (isContentEditable(el)) return true;
  return hasTabIndex(el);
}
function hasNegativeTabIndex(el) {
  return hasTabIndex(el) && el.tabIndex === -1;
}
function isTabbable(el) {
  return el ? isHTMLElement(el) && isFocusable(el) && !hasNegativeTabIndex(el) : false;
}
function isTouchDevice() {
  return "ontouchstart" in window;
}
function getOwnerWindow(node) {
  var _a;
  return (_a = getOwnerDocument(node).defaultView) != null ? _a : window;
}
function getOwnerDocument(el) {
  return isElement(el) ? el.ownerDocument : document;
}
function getActiveElement(el) {
  return getOwnerDocument(el).activeElement;
}
function isActiveElement(el) {
  return getActiveElement(el) === el;
}

// src/event.ts
function isMouseEvent(ev) {
  const win = getEventWindow(ev);
  if (typeof win.PointerEvent !== "undefined" && ev instanceof win.PointerEvent)
    return !!(ev.pointerType === "mouse");
  return ev instanceof win.MouseEvent;
}
function isTouchEvent(ev) {
  return !!ev.touches;
}
function isMultiTouchEvent(ev) {
  return isTouchEvent(ev) && ev.touches.length > 1;
}
function getEventWindow(ev) {
  var _a;
  return (_a = ev.view) != null ? _a : window;
}
function pointFromTouch(e, type = "page") {
  var _a, _b;
  const point = e.touches[0] || e.changedTouches[0];
  return { x: (_a = point == null ? void 0 : point[`${type}X`]) != null ? _a : 0, y: (_b = point == null ? void 0 : point[`${type}Y`]) != null ? _b : 0 };
}
function pointFromMouse(point, type = "page") {
  return {
    x: point[`${type}X`],
    y: point[`${type}Y`]
  };
}
function getEventPoint(ev, type = "page") {
  return isTouchEvent(ev) ? pointFromTouch(ev, type) : pointFromMouse(ev, type);
}
function addDomEvent(target, type, cb, options) {
  target.addEventListener(type, cb, options);
  return () => {
    target.removeEventListener(type, cb, options);
  };
}
function filter(cb) {
  return function(ev) {
    const isMouse = isMouseEvent(ev);
    if (!isMouse || ev.button === 0) cb(ev);
  };
}
function wrap(cb, filterPrimary = false) {
  function listener(ev) {
    return cb(ev, { point: getEventPoint(ev) });
  }
  const fn = filterPrimary ? filter(listener) : listener;
  return fn;
}
function addPointerEvent(target, type, cb, options) {
  return addDomEvent(target, type, wrap(cb, type === "pointerdown"), options);
}

// src/function.ts
var noop = () => {
};
function runIfFunc(valOrFunc, ...args) {
  return isFunction(valOrFunc) ? valOrFunc(...args) : valOrFunc;
}
function handlerAll(...funcs) {
  return function(event, ...args) {
    funcs.some((func) => {
      func == null ? void 0 : func(event, ...args);
      return event == null ? void 0 : event.defaultPrevented;
    });
  };
}
function funcAll(...funcs) {
  return function(...args) {
    return funcs.forEach((func) => func == null ? void 0 : func(...args));
  };
}

// src/module.ts
function interopDefault(module2) {
  return module2.default || module2;
}

// src/number.ts
function toNumber(n) {
  const num = parseFloat(n);
  return typeof num !== "number" || Number.isNaN(num) ? 0 : num;
}
function toPrecision(n, precision) {
  n = toNumber(n);
  const scale = 10 ** (precision != null ? precision : 10);
  n = Math.round(n * scale) / scale;
  return precision ? n.toFixed(precision) : n.toString();
}
function countDecimal(n) {
  if (!Number.isFinite(n)) return 0;
  let e = 1;
  let p = 0;
  while (Math.round(n * e) / e !== n) {
    e *= 10;
    p += 1;
  }
  return p;
}
function roundNumberToStep(n, from, step) {
  const nextValue = Math.round((n - from) / step) * step + from;
  const precision = countDecimal(step);
  return toPrecision(nextValue, precision);
}
function valueToPercent(n, min, max) {
  return (n - min) * 100 / (max - min);
}
function percentToValue(n, min, max) {
  return (max - min) * n + min;
}
function clampNumber(n, min, max) {
  return Math.min(Math.max(n, min), max);
}

// src/react.tsx
var React = __toESM(require("react"));
function createContext2({
  name,
  defaultValue,
  errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
  strict = true
} = {}) {
  const Context = React.createContext(defaultValue);
  Context.displayName = name;
  const useContext2 = () => {
    const context = React.useContext(Context);
    if (!context && strict) {
      const error = new Error(errorMessage);
      error.name = "ContextError";
      Error.captureStackTrace(error, useContext2);
      throw error;
    }
    return context;
  };
  return [Context.Provider, useContext2, Context];
}
var useSafeLayoutEffect = Boolean(globalThis.document) ? React.useLayoutEffect : React.useEffect;
function useUnmountEffect(callback) {
  return React.useEffect(() => () => callback(), []);
}
function useIsMounted({
  delay = 0,
  rerender = false
} = {}) {
  const isMountedRef = React.useRef(false);
  const [isMounted, setIsMounted] = React.useState(false);
  useSafeLayoutEffect(() => {
    isMountedRef.current = true;
    let timeoutId = null;
    if (rerender) {
      if (delay > 0) {
        timeoutId = setTimeout(() => setIsMounted(true), delay);
      } else {
        setIsMounted(true);
      }
    }
    return () => {
      isMountedRef.current = false;
      if (rerender) setIsMounted(false);
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, [delay, rerender]);
  return [React.useCallback(() => isMountedRef.current, []), isMounted];
}
function getValidChildren(children) {
  return React.Children.toArray(children).filter(
    (child) => React.isValidElement(child)
  );
}
function isValidElement2(child) {
  return React.isValidElement(child) || isString(child) || isNumber(child);
}
function isSomeElement(child, type) {
  var _a, _b;
  if (child.type === type) return true;
  if (!!child.__ui__ && !!type.__ui__) {
    if (child.__ui__ === type.__ui__) return true;
  }
  const payload = child.type._payload;
  if (!!((_a = payload == null ? void 0 : payload.value) == null ? void 0 : _a.__ui__) && !!type.__ui__) {
    if (((_b = payload == null ? void 0 : payload.value) == null ? void 0 : _b.__ui__) === type.__ui__) return true;
  }
  return false;
}
function findChild(children, ...types) {
  const child = children.find(
    (child2) => types.some((type) => isSomeElement(child2, type))
  );
  return child;
}
function findChildren(children, ...types) {
  const child = children.find(
    (child2) => types.some((type) => isSomeElement(child2, type))
  );
  if (child) {
    return children.sort((a, b) => {
      if (types.some((type) => isSomeElement(a, type))) {
        return -1;
      } else if (types.some((type) => isSomeElement(b, type))) {
        return 1;
      } else {
        return 0;
      }
    });
  } else {
    return [void 0, ...children];
  }
}
function includesChildren(children, ...types) {
  return children.some((child) => {
    if (types.some((type) => isSomeElement(child, type))) return true;
    const children2 = getValidChildren(child.props.children);
    return children2.length ? includesChildren(children2, ...types) : false;
  });
}
function omitChildren(children, ...types) {
  return children.filter(
    (child) => types.every((type) => !isSomeElement(child, type))
  );
}
function pickChildren(children, ...types) {
  return children.filter(
    (child) => types.every((type) => isSomeElement(child, type))
  );
}
function cx(...classNames) {
  return classNames.filter(Boolean).join(" ");
}
function isRefObject(val) {
  return isObject(val) && "current" in val;
}
function assignRef(ref, value) {
  if (ref == null) return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return function(node) {
    return refs.forEach((ref) => {
      assignRef(ref, node);
    });
  };
}
function useMergeRefs(...refs) {
  return React.useMemo(() => mergeRefs(...refs), [refs]);
}
function useCallbackRef(callback, deps = []) {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useCallback(
    (...args) => {
      var _a;
      return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
}
function useUpdateEffect(callback, deps) {
  const renderCycleRef = React.useRef(false);
  const effectCycleRef = React.useRef(false);
  React.useEffect(() => {
    const mounted = renderCycleRef.current;
    const run = mounted && effectCycleRef.current;
    if (run) return callback();
    effectCycleRef.current = true;
  }, deps);
  React.useEffect(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
}
function useAsync(func, deps = []) {
  const [state, callback] = useAsyncFunc(func, deps, { loading: true });
  React.useEffect(() => {
    callback();
  }, [callback]);
  return state;
}
function useAsyncFunc(func, deps = [], initialState = { loading: false }) {
  const lastCallId = React.useRef(0);
  const [isMounted] = useIsMounted();
  const [state, setState] = React.useState(initialState);
  const callback = React.useCallback(
    (...args) => {
      const callId = ++lastCallId.current;
      if (!state.loading)
        setState((prevState) => ({ ...prevState, loading: true }));
      return func(...args).then(
        (value) => {
          if (isMounted() && callId === lastCallId.current)
            setState({ loading: false, value });
          return value;
        },
        (error) => {
          if (isMounted() && callId === lastCallId.current)
            setState({ error, loading: false });
          return error;
        }
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  return [state, callback];
}
function useAsyncRetry(func, deps = []) {
  const [attempt, setAttempt] = React.useState(0);
  const state = useAsync(func, [...deps, attempt]);
  const stateLoading = state.loading;
  const retry = React.useCallback(() => {
    if (stateLoading) return;
    setAttempt((currentAttempt) => currentAttempt + 1);
  }, [...deps, stateLoading]);
  return { ...state, retry };
}
var createIdCounter = 0;
function createId(prefix) {
  return `${prefix}-${++createIdCounter}-${(/* @__PURE__ */ new Date()).getTime()}`;
}

// src/string.ts
function escape(value, replaceValue = "") {
  return value.replace(/\s+/g, replaceValue);
}
function antonym(value) {
  switch (value) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "left":
      return "right";
    case "right":
      return "left";
    case "start":
      return "end";
    case "end":
      return "start";
    case "x":
      return "y";
    case "y":
      return "x";
    case "enter":
      return "exit";
    case "exit":
      return "enter";
    case "vertical":
      return "horizontal";
    case "horizontal":
      return "vertical";
    case "up":
      return "down";
    case "down":
      return "up";
    case "block":
      return "inline";
    case "inline":
      return "block";
    default:
      return value;
  }
}
var sizeMap = [
  "9xs",
  "8xs",
  "7xs",
  "6xs",
  "5xs",
  "4xs",
  "3xs",
  "2xs",
  "xs",
  "sm",
  "md",
  "normal",
  "lg",
  "xl",
  "2xl",
  "3xl",
  "4xl",
  "5xl",
  "6xl",
  "7xl",
  "8xl",
  "9xl"
];
function transformSize(token, value, omitTokens = ["normal"]) {
  if (!token) return void 0;
  let resolvedSizeMap = sizeMap;
  if (omitTokens)
    resolvedSizeMap = sizeMap.filter((size2) => !omitTokens.includes(size2));
  const index = resolvedSizeMap.indexOf(token);
  const size = resolvedSizeMap[index + value];
  return size != null ? size : token;
}
function toCamelCase(value) {
  return value.toLowerCase().replace(/[_-](.)/g, (_, val) => val.toUpperCase());
}
function toPascalCase(value) {
  return toCamelCase(value).replace(/^(.)/, (_, val) => val.toUpperCase());
}
function toKebabCase(value) {
  return value.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase().replace(/^-/, "");
}
function toTitleCase(value) {
  return value.replace(/([A-Z])/g, " $1").replace(/[_-](.)/g, (_, val) => ` ${val.toUpperCase()}`).replace(/^./, (str) => str.toUpperCase()).trim();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  COLOR_SCHEMES,
  SEMANTIC_COLOR_SCHEMES,
  TONES,
  addDomEvent,
  addPointerEvent,
  alphaToHex,
  antonym,
  ariaAttr,
  assignAfter,
  assignRef,
  calc,
  calcFormat,
  cast,
  clampNumber,
  convertColor,
  countDecimal,
  createContext,
  createId,
  createdDom,
  cx,
  darkenColor,
  dataAttr,
  escape,
  filterEmpty,
  filterObject,
  filterUndefined,
  findChild,
  findChildren,
  flattenObject,
  funcAll,
  getActiveElement,
  getAllFocusable,
  getAlpha,
  getColor,
  getEventPoint,
  getEventRelatedTarget,
  getEventWindow,
  getMemoizedObject,
  getObject,
  getOwnerDocument,
  getOwnerWindow,
  getPlatform,
  getPx,
  getValidChildren,
  handlerAll,
  hasNegativeTabIndex,
  hasTabIndex,
  hslaTo,
  hsvTo,
  includesChildren,
  interopDefault,
  is,
  isAccessible,
  isActiveElement,
  isApple,
  isArray,
  isBoolean,
  isContains,
  isContentEditable,
  isDark,
  isDisabled,
  isElement,
  isEmpty,
  isEmptyObject,
  isFocusable,
  isFunction,
  isGray,
  isHTMLElement,
  isHidden,
  isLight,
  isMac,
  isMouseEvent,
  isMultiTouchEvent,
  isNotNumber,
  isNull,
  isNumber,
  isNumeric,
  isObject,
  isRefObject,
  isSafari,
  isSomeElement,
  isString,
  isTabbable,
  isTone,
  isTouchDevice,
  isTouchEvent,
  isUndefined,
  isUnit,
  isValidElement,
  keysFormObject,
  lightenColor,
  memoizeObject,
  merge,
  mergeRefs,
  noop,
  objectFromEntries,
  omitChildren,
  omitObject,
  parseToHsla,
  parseToHsv,
  parseToRgba,
  percentToValue,
  pickChildren,
  pickObject,
  platform,
  pointFromMouse,
  pointFromTouch,
  randomColor,
  replaceObject,
  rgbaTo,
  roundNumberToStep,
  runIfFunc,
  sameColor,
  shadeColor,
  splitObject,
  tintColor,
  toCamelCase,
  toKebabCase,
  toNumber,
  toPascalCase,
  toPrecision,
  toTitleCase,
  transformSize,
  transparentizeColor,
  useAsync,
  useAsyncFunc,
  useAsyncRetry,
  useCallbackRef,
  useIsMounted,
  useMergeRefs,
  useSafeLayoutEffect,
  useUnmountEffect,
  useUpdateEffect,
  valueToPercent,
  vendor
});
//# sourceMappingURL=index.js.map