{"version":3,"sources":["../src/react.tsx","../src/assertion.ts"],"sourcesContent":["import * as React from \"react\"\nimport { isNumber, isObject, isString } from \"./assertion\"\n\nexport type MaybeRenderProp<Y> =\n  | ((props: Y) => React.ReactNode)\n  | React.ReactNode\n\ninterface Options<Y = any> {\n  name?: string\n  defaultValue?: Y\n  errorMessage?: string\n  strict?: boolean\n}\n\ntype CreateContextReturn<Y> = [React.Provider<Y>, () => Y, React.Context<Y>]\n\nexport function createContext<Y = any>(options: {\n  name?: string\n  defaultValue?: Y\n  errorMessage?: string\n  strict?: true\n}): CreateContextReturn<Y>\n\nexport function createContext<Y = any>(options: {\n  name?: string\n  defaultValue?: Y\n  errorMessage?: string\n  strict?: false\n}): CreateContextReturn<undefined | Y>\n\nexport function createContext<Y = any>({\n  name,\n  defaultValue,\n  errorMessage = \"useContext: `context` is undefined. Seems you forgot to wrap component within the Provider\",\n  strict = true,\n}: Options<Y> = {}) {\n  const Context = React.createContext<undefined | Y>(defaultValue)\n\n  Context.displayName = name\n\n  const useContext = () => {\n    const context = React.useContext(Context)\n\n    if (!context && strict) {\n      const error = new Error(errorMessage)\n      error.name = \"ContextError\"\n      Error.captureStackTrace(error, useContext)\n      throw error\n    }\n\n    return context\n  }\n\n  return [Context.Provider, useContext, Context] as CreateContextReturn<\n    undefined | Y\n  >\n}\n\nexport const useSafeLayoutEffect = Boolean(globalThis.document)\n  ? React.useLayoutEffect\n  : React.useEffect\n\nexport function useUnmountEffect(callback: () => void) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useEffect(() => () => callback(), [])\n}\n\nexport interface UseIsMountedProps {\n  delay?: number\n  rerender?: boolean\n}\n\nexport function useIsMounted({\n  delay = 0,\n  rerender = false,\n}: UseIsMountedProps = {}): [() => boolean, boolean] {\n  const isMountedRef = React.useRef(false)\n  const [isMounted, setIsMounted] = React.useState(false)\n\n  useSafeLayoutEffect(() => {\n    isMountedRef.current = true\n\n    let timeoutId: any = null\n\n    if (rerender) {\n      if (delay > 0) {\n        timeoutId = setTimeout(() => setIsMounted(true), delay)\n      } else {\n        setIsMounted(true)\n      }\n    }\n\n    return () => {\n      isMountedRef.current = false\n\n      if (rerender) setIsMounted(false)\n\n      if (timeoutId) clearTimeout(timeoutId)\n    }\n  }, [delay, rerender])\n\n  return [React.useCallback(() => isMountedRef.current, []), isMounted]\n}\n\nexport type UseIsMountedReturn = ReturnType<typeof useIsMounted>\n\nexport function getValidChildren(\n  children: React.ReactNode,\n): React.ReactElement[] {\n  return React.Children.toArray(children).filter((child) =>\n    React.isValidElement(child),\n  )\n}\n\nexport function isValidElement(child: any): child is React.ReactNode {\n  return React.isValidElement(child) || isString(child) || isNumber(child)\n}\n\nexport function isSomeElement(child: any, type: any): boolean {\n  if (child.type === type) return true\n\n  if (!!child.__ui__ && !!type.__ui__) {\n    if (child.__ui__ === type.__ui__) return true\n  }\n\n  const payload = child.type._payload\n\n  if (!!payload?.value?.__ui__ && !!type.__ui__) {\n    if (payload?.value?.__ui__ === type.__ui__) return true\n  }\n\n  return false\n}\n\nexport function findChild(\n  children: React.ReactElement[],\n  ...types: (React.JSXElementConstructor<any> | string)[]\n): React.ReactElement | undefined {\n  const child = children.find((child) =>\n    types.some((type) => isSomeElement(child, type)),\n  )\n\n  return child\n}\n\nexport function findChildren(\n  children: React.ReactElement[],\n  ...types: (React.JSXElementConstructor<any> | string)[]\n): [React.ReactElement | undefined, ...React.ReactElement[]] {\n  const child = children.find((child) =>\n    types.some((type) => isSomeElement(child, type)),\n  )\n\n  if (child) {\n    return children.sort((a, b) => {\n      if (types.some((type) => isSomeElement(a, type))) {\n        return -1\n      } else if (types.some((type) => isSomeElement(b, type))) {\n        return 1\n      } else {\n        return 0\n      }\n    }) as [React.ReactElement | undefined, ...React.ReactElement[]]\n  } else {\n    return [undefined, ...children]\n  }\n}\n\nexport function includesChildren(\n  children: React.ReactElement[],\n  ...types: (React.JSXElementConstructor<any> | string)[]\n): boolean {\n  return children.some((child) => {\n    if (types.some((type) => isSomeElement(child, type))) return true\n\n    const children = getValidChildren(child.props.children)\n\n    return children.length ? includesChildren(children, ...types) : false\n  })\n}\n\nexport function omitChildren(\n  children: React.ReactElement[],\n  ...types: (React.JSXElementConstructor<any> | string)[]\n): React.ReactElement[] {\n  return children.filter((child) =>\n    types.every((type) => !isSomeElement(child, type)),\n  )\n}\n\nexport function pickChildren(\n  children: React.ReactElement[],\n  ...types: (React.JSXElementConstructor<any> | string)[]\n): React.ReactElement[] {\n  return children.filter((child) =>\n    types.every((type) => isSomeElement(child, type)),\n  )\n}\n\nexport function cx(...classNames: (string | undefined)[]) {\n  return classNames.filter(Boolean).join(\" \")\n}\n\ntype ReactRef<T> = React.LegacyRef<T> | React.MutableRefObject<T> | React.Ref<T>\n\nexport function isRefObject(val: any): val is { current: any } {\n  return isObject(val) && \"current\" in val\n}\n\nexport function assignRef<T = any>(ref: ReactRef<T> | undefined, value: T) {\n  if (ref == null) return\n\n  if (typeof ref === \"function\") {\n    ref(value)\n\n    return\n  }\n\n  try {\n    // @ts-ignore\n    ref.current = value\n  } catch {\n    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`)\n  }\n}\n\nexport function mergeRefs<T = any>(\n  ...refs: (null | ReactRef<T> | undefined)[]\n) {\n  return function (node: null | T) {\n    return refs.forEach((ref) => {\n      assignRef(ref, node)\n    })\n  }\n}\n\nexport function useMergeRefs<T = any>(...refs: (ReactRef<T> | undefined)[]) {\n  return React.useMemo(() => mergeRefs(...refs), [refs])\n}\n\nexport function useCallbackRef<T extends (...args: any[]) => any>(\n  callback: T | undefined,\n  deps: React.DependencyList = [],\n) {\n  const callbackRef = React.useRef(callback)\n\n  React.useEffect(() => {\n    callbackRef.current = callback\n  })\n\n  return React.useCallback(\n    ((...args) => callbackRef.current?.(...args)) as T,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps,\n  )\n}\n\n/**\n * `useUpdateEffect` is a custom hook that skips side effects on the initial render, and only runs them when the dependency array changes.\n *\n * @see Docs https://yamada-ui.com/hooks/use-update-effect\n */\nexport function useUpdateEffect(\n  callback: React.EffectCallback,\n  deps: React.DependencyList,\n) {\n  const renderCycleRef = React.useRef(false)\n  const effectCycleRef = React.useRef(false)\n\n  React.useEffect(() => {\n    const mounted = renderCycleRef.current\n    const run = mounted && effectCycleRef.current\n\n    if (run) return callback()\n\n    effectCycleRef.current = true\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps)\n\n  React.useEffect(() => {\n    renderCycleRef.current = true\n\n    return () => {\n      renderCycleRef.current = false\n    }\n  }, [])\n}\n\nexport type FunctionReturningPromise = (...args: any[]) => Promise<any>\n\n/**\n * `useAsync` is a custom hook that executes an asynchronous function and tracks its state.\n *\n * @see Docs https://yamada-ui.com/hooks/use-async\n */\nexport function useAsync<T extends FunctionReturningPromise>(\n  func: T,\n  deps: React.DependencyList = [],\n) {\n  const [state, callback] = useAsyncFunc(func, deps, { loading: true })\n\n  React.useEffect(() => {\n    callback()\n  }, [callback])\n\n  return state\n}\n\nexport type AsyncState<T> =\n  | {\n      error: Error\n      loading: false\n      value?: undefined\n    }\n  | {\n      loading: boolean\n      error?: undefined\n      value?: undefined\n    }\n  | {\n      loading: false\n      value: T\n      error?: undefined\n    }\n  | {\n      loading: true\n      error?: Error | undefined\n      value?: T\n    }\n\nexport type PromiseType<P extends Promise<any>> =\n  P extends Promise<infer T> ? T : never\n\ntype StateFromFunctionReturningPromise<T extends FunctionReturningPromise> =\n  AsyncState<PromiseType<ReturnType<T>>>\n\nexport type AsyncFnReturn<\n  T extends FunctionReturningPromise = FunctionReturningPromise,\n> = [StateFromFunctionReturningPromise<T>, T]\n\nexport function useAsyncFunc<T extends FunctionReturningPromise>(\n  func: T,\n  deps: React.DependencyList = [],\n  initialState: StateFromFunctionReturningPromise<T> = { loading: false },\n): AsyncFnReturn<T> {\n  const lastCallId = React.useRef(0)\n  const [isMounted] = useIsMounted()\n  const [state, setState] =\n    React.useState<StateFromFunctionReturningPromise<T>>(initialState)\n\n  const callback = React.useCallback(\n    (...args: Parameters<T>): ReturnType<T> => {\n      const callId = ++lastCallId.current\n\n      if (!state.loading)\n        setState((prevState) => ({ ...prevState, loading: true }))\n\n      return func(...args).then(\n        (value) => {\n          if (isMounted() && callId === lastCallId.current)\n            setState({ loading: false, value })\n\n          return value\n        },\n        (error) => {\n          if (isMounted() && callId === lastCallId.current)\n            setState({ error, loading: false })\n\n          return error\n        },\n      ) as ReturnType<T>\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps,\n  )\n\n  return [state, callback as unknown as T]\n}\n\nexport type AsyncStateRetry<T> = {\n  retry(): void\n} & AsyncState<T>\n\nexport function useAsyncRetry<T>(\n  func: () => Promise<T>,\n  deps: React.DependencyList = [],\n) {\n  const [attempt, setAttempt] = React.useState<number>(0)\n  const state = useAsync(func, [...deps, attempt])\n\n  const stateLoading = state.loading\n\n  const retry = React.useCallback(() => {\n    if (stateLoading) return\n\n    setAttempt((currentAttempt) => currentAttempt + 1)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [...deps, stateLoading])\n\n  return { ...state, retry }\n}\n\nlet createIdCounter = 0\n\nexport function createId(prefix: string) {\n  return `${prefix}-${++createIdCounter}-${new Date().getTime()}`\n}\n","import type { Dict } from \"./index.types\"\n\nexport function is(x: any, y: any) {\n  return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y)\n}\n\nexport function isNumber(value: any): value is number {\n  return typeof value === \"number\"\n}\n\nexport function isNotNumber(value: any): boolean {\n  return (\n    typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)\n  )\n}\n\nexport function isNumeric(value: any): boolean {\n  return (\n    !isNaN(parseFloat(String(value))) &&\n    isFinite(Number(value)) &&\n    /^-?\\d*\\.?\\d+$/.test(String(value))\n  )\n}\n\nexport function isString(value: any): value is string {\n  return Object.prototype.toString.call(value) === \"[object String]\"\n}\n\nexport function isBoolean(value: any): value is boolean {\n  return typeof value === \"boolean\"\n}\n\nexport function isUndefined(value: any): value is undefined {\n  return typeof value === \"undefined\"\n}\n\nexport function isNull(value: any): value is null {\n  return value === null\n}\n\nexport function isObject<T extends Dict>(value: any): value is T {\n  return (\n    value !== null &&\n    (typeof value === \"object\" || typeof value === \"function\") &&\n    !isArray(value)\n  )\n}\n\nexport function isArray<T extends any[]>(value: any): value is T {\n  return Array.isArray(value)\n}\n\nexport function isEmpty(value: any): boolean {\n  return !isArray(value) || !value.length || value.every((v) => v == null)\n}\n\nexport function isEmptyObject(value: any): boolean {\n  return isObject(value) && !Object.keys(value).length\n}\n\nexport function isFunction<T extends Function = Function>(\n  value: any,\n): value is T {\n  return typeof value === \"function\"\n}\n\nexport function isUnit(value: any): boolean {\n  return /[0-9].*(em|rem|ex|rex|cap|rcap|ch|rch|ic|ric|lh|rlh|vw|svw|lvw|dvw|vh|svh|lvh|dvh|vi|svi|lvi|dvi|vb|svb|lvb|dvb|vmin|svmin|lvmin|dvmin|vmax|svmax|lvmax|dvmax|cm|mm|Q|in|pc|pt|px|%|cqw|cqh|cqi|cqb|cqmin|cqmax)$/.test(\n    value,\n  )\n}\n\nexport function cast<T>(value: any) {\n  return value as T\n}\n"],"mappings":"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","names":["createContext","isValidElement","createContext","useContext","isValidElement","child","children"]}