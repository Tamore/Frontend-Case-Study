{"version":3,"sources":["../src/color.ts","../src/assertion.ts","../src/object.ts"],"sourcesContent":["import type { Dict, StringLiteral } from \"./index.types\"\nimport * as c from \"color2k\"\nimport { isArray, isNumber, isObject } from \"./assertion\"\nimport { getMemoizedObject as get } from \"./object\"\n\ntype ThemeValue = number | string\ntype Breakpoint = \"base\" | StringLiteral\ntype ColorMode = \"dark\" | \"light\"\n\nexport type ColorFormat = \"hex\" | \"hexa\" | \"hsl\" | \"hsla\" | \"rgb\" | \"rgba\"\n\nexport const SEMANTIC_COLOR_SCHEMES = [\n  \"primary\",\n  \"secondary\",\n  \"info\",\n  \"success\",\n  \"warning\",\n  \"danger\",\n  \"link\",\n] as const\n\nexport const COLOR_SCHEMES = [\n  \"gray\",\n  \"neutral\",\n  \"red\",\n  \"rose\",\n  \"pink\",\n  \"flashy\",\n  \"orange\",\n  \"amber\",\n  \"yellow\",\n  \"lime\",\n  \"green\",\n  \"emerald\",\n  \"teal\",\n  \"cyan\",\n  \"sky\",\n  \"blue\",\n  \"indigo\",\n  \"violet\",\n  \"purple\",\n  \"fuchsia\",\n] as const\n\nexport type SemanticColorScheme =\n  | (typeof SEMANTIC_COLOR_SCHEMES)[number]\n  | StringLiteral\nexport type ColorScheme = (typeof COLOR_SCHEMES)[number] | StringLiteral\n\nexport const TONES = [\n  50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950,\n] as const\n\nexport function isGray(colorScheme: string) {\n  return colorScheme === \"gray\" || colorScheme === \"neutral\"\n}\n\nexport function isAccessible(colorScheme: string) {\n  return (\n    colorScheme === \"yellow\" || colorScheme === \"cyan\" || colorScheme === \"lime\"\n  )\n}\n\nexport function getColor(color: string, fallback = \"#000000\") {\n  return function (\n    theme: Dict = {},\n    colorMode: ColorMode = \"light\",\n    breakpoint: Breakpoint = \"base\",\n  ) {\n    const [token, tone] = color.split(\".\")\n\n    if (tone) {\n      const [, relatedToken] =\n        Object.entries<string>(theme.semantics?.colorSchemes ?? {}).find(\n          ([semanticToken]) => token === semanticToken,\n        ) ?? []\n\n      if (relatedToken) color = `${relatedToken}.${tone}`\n    } else {\n      const [, relatedColor] =\n        Object.entries<string>(theme.semantics?.colors ?? {}).find(\n          ([semanticToken]) => token === semanticToken,\n        ) ?? []\n\n      if (relatedColor) color = relatedColor\n    }\n\n    const hex = get<[ThemeValue, ThemeValue] | Dict<ThemeValue> | ThemeValue>(\n      theme,\n      `colors.${color}`,\n      color,\n    )\n\n    try {\n      if (isArray(hex)) {\n        return c.toHex(String(hex[colorMode !== \"dark\" ? 0 : 1]))\n      } else if (isObject(hex)) {\n        return c.toHex(String(hex[breakpoint]))\n      } else {\n        return c.toHex(String(hex))\n      }\n    } catch {\n      try {\n        return c.toHex(fallback)\n      } catch {\n        return \"#000000\"\n      }\n    }\n  }\n}\n\nexport function lightenColor(color: string, amount: number) {\n  return function (\n    theme?: Dict,\n    colorMode?: ColorMode,\n    breakpoint?: Breakpoint,\n  ) {\n    const raw = getColor(color, color)(theme, colorMode, breakpoint)\n\n    return c.toHex(c.lighten(raw, amount / 100))\n  }\n}\n\nexport function darkenColor(color: string, amount: number) {\n  return function (\n    theme?: Dict,\n    colorMode?: ColorMode,\n    breakpoint?: Breakpoint,\n  ) {\n    const raw = getColor(color, color)(theme, colorMode, breakpoint)\n\n    return c.toHex(c.darken(raw, amount / 100))\n  }\n}\n\nexport function tintColor(color: string, amount: number) {\n  return function (\n    theme?: Dict,\n    colorMode?: ColorMode,\n    breakpoint?: Breakpoint,\n  ) {\n    const raw = getColor(color, color)(theme, colorMode, breakpoint)\n\n    return c.toHex(c.mix(raw, \"#fff\", amount / 100))\n  }\n}\n\nexport function shadeColor(color: string, amount: number) {\n  return function (\n    theme?: Dict,\n    colorMode?: ColorMode,\n    breakpoint?: Breakpoint,\n  ) {\n    const raw = getColor(color, color)(theme, colorMode, breakpoint)\n\n    return c.toHex(c.mix(raw, \"#000\", amount / 100))\n  }\n}\n\nexport function transparentizeColor(color: string, alpha: number) {\n  return function (\n    theme?: Dict,\n    colorMode?: ColorMode,\n    breakpoint?: Breakpoint,\n  ) {\n    const raw = getColor(color, color)(theme, colorMode, breakpoint)\n\n    return c.transparentize(raw, 1 - alpha)\n  }\n}\n\nexport function randomColor({\n  colors,\n  string,\n}: { colors?: string[]; string?: string } = {}) {\n  const fallback = randomHex()\n\n  if (string && colors) return randomColorFromList(string, colors) ?? fallback\n\n  if (string && !colors) return randomColorFromString(string)\n\n  if (colors && !string) return randomFromList(colors) ?? fallback\n\n  return fallback\n}\n\nfunction randomHex() {\n  return `#${Math.floor(Math.random() * 0xffffff)\n    .toString(16)\n    .padEnd(6, \"0\")}`\n}\n\nfunction randomColorFromString(str: string) {\n  let hash = 0\n\n  if (str.length === 0) return hash.toString()\n\n  for (let i = 0; i < str.length; i += 1) {\n    hash = str.charCodeAt(i) + ((hash << 5) - hash)\n    hash = hash & hash\n  }\n\n  let color = \"#\"\n\n  for (let j = 0; j < 3; j += 1) {\n    const value = (hash >> (j * 8)) & 255\n\n    color += `00${value.toString(16)}`.substr(-2)\n  }\n\n  return color\n}\n\nfunction randomColorFromList(str: string, list: string[]) {\n  let index = 0\n\n  if (str.length === 0) return list[0]\n\n  for (let i = 0; i < str.length; i += 1) {\n    index = str.charCodeAt(i) + ((index << 5) - index)\n\n    index = index & index\n  }\n\n  index = ((index % list.length) + list.length) % list.length\n\n  return list[index]\n}\n\nfunction randomFromList(list: string[]) {\n  return list[Math.floor(Math.random() * list.length)]\n}\n\nfunction getBrightness(color: string) {\n  const [r, g, b] = c.parseToRgba(color)\n\n  return (r * 299 + g * 587 + b * 114) / 1000\n}\n\nexport function isTone(color: string) {\n  return function (\n    theme?: Dict,\n    colorMode?: ColorMode,\n    breakpoint?: Breakpoint,\n  ) {\n    const raw = theme ? getColor(color)(theme, colorMode, breakpoint) : color\n\n    const brightness = getBrightness(raw)\n\n    const isDark = brightness < 128\n\n    return isDark ? \"dark\" : \"light\"\n  }\n}\n\nexport function isLight(color: string) {\n  return function (theme?: Dict, colorMode?: ColorMode) {\n    return isTone(color)(theme, colorMode) === \"dark\"\n  }\n}\n\nexport function isDark(color: string) {\n  return function (theme?: Dict, colorMode?: ColorMode) {\n    return isTone(color)(theme, colorMode) === \"light\"\n  }\n}\n\nexport function convertColor(color: string, fallback?: string) {\n  return function (format: ColorFormat): string | undefined {\n    try {\n      const isAlpha = format.endsWith(\"a\")\n\n      if (/^[0-9a-fA-F]{6}$/.test(color)) color = \"#\" + color\n\n      if (format.startsWith(\"hex\")) {\n        let hexa = c.toHex(color)\n\n        if (isAlpha) {\n          if (hexa.length === 7) hexa += \"ff\"\n        } else {\n          hexa = hexa.replace(/(?<=^#([0-9a-fA-F]{6}))[0-9a-fA-F]{2}$/, \"\")\n        }\n\n        return hexa\n      } else if (format.startsWith(\"hsl\")) {\n        let hsla = c.toHsla(color)\n\n        if (!isAlpha) {\n          hsla = hsla.replace(/hsla/, \"hsl\")\n          hsla = hsla.replace(/,\\s*\\d+(\\.\\d+)?\\)$/, \")\")\n        }\n\n        return hsla\n      } else {\n        let rgba = c.toRgba(color)\n\n        if (!isAlpha) {\n          rgba = rgba.replace(/rgba/, \"rgb\")\n          rgba = rgba.replace(/,\\s*\\d+(\\.\\d+)?\\)$/, \")\")\n        }\n\n        return rgba\n      }\n    } catch {\n      if (fallback) return convertColor(fallback)(format)\n    }\n  }\n}\n\nexport function calcFormat(color: string): ColorFormat {\n  if (color.startsWith(\"hsl\")) {\n    return color.startsWith(\"hsla\") ? \"hsla\" : \"hsl\"\n  } else if (color.startsWith(\"rgb\")) {\n    return color.startsWith(\"rgba\") ? \"rgba\" : \"rgb\"\n  } else {\n    return color.length === 9 ? \"hexa\" : \"hex\"\n  }\n}\n\nexport function getAlpha(color: string) {\n  return c.parseToRgba(color)[3]\n}\n\nexport function alphaToHex(a: number) {\n  if (0 > a) a = 0\n  if (1 < a) a = 1\n\n  return Math.round(a * 255)\n    .toString(16)\n    .padStart(2, \"0\")\n}\n\nexport function parseToRgba(color: string, fallback?: string) {\n  try {\n    if (/^[0-9a-fA-F]{6}$/.test(color)) color = \"#\" + color\n\n    return c.parseToRgba(color)\n  } catch {\n    if (fallback) return c.parseToRgba(fallback)\n  }\n}\n\nexport function parseToHsla(color: string, fallback?: string) {\n  try {\n    if (/^[0-9a-fA-F]{6}$/.test(color)) color = \"#\" + color\n\n    return c.parseToHsla(color)\n  } catch {\n    if (fallback) return c.parseToHsla(fallback)\n  }\n}\n\nexport function parseToHsv(\n  color: string,\n  fallback?: string,\n): [number, number, number, number] {\n  let [r, g, b, a] = parseToRgba(color, fallback) ?? [255, 255, 255, 1]\n\n  r = r / 255\n  g = g / 255\n  b = b / 255\n\n  const [min, max] = [Math.min(r, g, b), Math.max(r, g, b)]\n  const delta = max - min\n\n  let [h, v, s] = [0, max, max == 0 ? 0 : delta / max]\n\n  switch (min) {\n    case max:\n      h = 0\n      break\n\n    case r:\n      h = 60 * ((b - g) / delta) + 180\n      break\n\n    case g:\n      h = 60 * ((r - b) / delta) + 300\n      break\n\n    case b:\n      h = 60 * ((g - r) / delta) + 60\n      break\n  }\n\n  return [h, s, v, a]\n}\n\nexport function rgbaTo(\n  [r, g, b, a]: [number, number, number, number],\n  fallback?: string,\n) {\n  return function (format: ColorFormat = \"hex\") {\n    return convertColor(c.rgba(r, g, b, a), fallback)(format)\n  }\n}\n\nexport function hslaTo(\n  [h, s, l, a]: [number, number, number, number],\n  fallback?: string,\n) {\n  return function (format: ColorFormat = \"hex\") {\n    return convertColor(c.hsla(h, s, l, a), fallback)(format)\n  }\n}\n\nexport function hsvTo(\n  [h, s, v, a]: [number, number, number, number?],\n  fallback?: string,\n) {\n  return function (format: ColorFormat = \"hex\"): string | undefined {\n    h = h / 60\n\n    let rgb: [number, number, number] = [v, v, v]\n\n    let i = Math.floor(h)\n    let f = h - i\n    let p = v * (1 - s)\n    let q = v * (1 - s * f)\n    let t = v * (1 - s * (1 - f))\n\n    switch (i) {\n      case 0:\n      case 6:\n        rgb = [v, t, p]\n        break\n\n      case 1:\n        rgb = [q, v, p]\n        break\n\n      case 2:\n        rgb = [p, v, t]\n        break\n\n      case 3:\n        rgb = [p, q, v]\n        break\n\n      case 4:\n        rgb = [t, p, v]\n        break\n\n      case 5:\n        rgb = [v, p, q]\n        break\n    }\n\n    let color = `rgb(${rgb.map((v) => Math.round(v * 255)).join(\", \")})`\n\n    if (isNumber(a)) color = color.replace(/\\)$/, `, ${a})`)\n\n    return convertColor(color, fallback)(format)\n  }\n}\n\nexport function sameColor(\n  color: string | undefined,\n  comparison: string | undefined,\n) {\n  if (!color) return false\n  if (!comparison) return false\n\n  const a = parseToRgba(color) ?? []\n  const b = parseToRgba(comparison) ?? []\n\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]\n}\n","import type { Dict } from \"./index.types\"\n\nexport function is(x: any, y: any) {\n  return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y)\n}\n\nexport function isNumber(value: any): value is number {\n  return typeof value === \"number\"\n}\n\nexport function isNotNumber(value: any): boolean {\n  return (\n    typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)\n  )\n}\n\nexport function isNumeric(value: any): boolean {\n  return (\n    !isNaN(parseFloat(String(value))) &&\n    isFinite(Number(value)) &&\n    /^-?\\d*\\.?\\d+$/.test(String(value))\n  )\n}\n\nexport function isString(value: any): value is string {\n  return Object.prototype.toString.call(value) === \"[object String]\"\n}\n\nexport function isBoolean(value: any): value is boolean {\n  return typeof value === \"boolean\"\n}\n\nexport function isUndefined(value: any): value is undefined {\n  return typeof value === \"undefined\"\n}\n\nexport function isNull(value: any): value is null {\n  return value === null\n}\n\nexport function isObject<T extends Dict>(value: any): value is T {\n  return (\n    value !== null &&\n    (typeof value === \"object\" || typeof value === \"function\") &&\n    !isArray(value)\n  )\n}\n\nexport function isArray<T extends any[]>(value: any): value is T {\n  return Array.isArray(value)\n}\n\nexport function isEmpty(value: any): boolean {\n  return !isArray(value) || !value.length || value.every((v) => v == null)\n}\n\nexport function isEmptyObject(value: any): boolean {\n  return isObject(value) && !Object.keys(value).length\n}\n\nexport function isFunction<T extends Function = Function>(\n  value: any,\n): value is T {\n  return typeof value === \"function\"\n}\n\nexport function isUnit(value: any): boolean {\n  return /[0-9].*(em|rem|ex|rex|cap|rcap|ch|rch|ic|ric|lh|rlh|vw|svw|lvw|dvw|vh|svh|lvh|dvh|vi|svi|lvi|dvi|vb|svb|lvb|dvb|vmin|svmin|lvmin|dvmin|vmax|svmax|lvmax|dvmax|cm|mm|Q|in|pc|pt|px|%|cqw|cqh|cqi|cqb|cqmin|cqmax)$/.test(\n    value,\n  )\n}\n\nexport function cast<T>(value: any) {\n  return value as T\n}\n","import type { Dict } from \"./index.types\"\nimport {\n  isArray,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n} from \"./assertion\"\n\nfunction omitObjectHelper<Y extends Dict, M extends keyof Y>(\n  obj: Y,\n  path: M[] | readonly M[],\n): any {\n  if (!path.length) return obj\n\n  const [primaryKey, ...restKeys] = path\n\n  if (restKeys.length === 0 && primaryKey && primaryKey in obj) {\n    const { [primaryKey]: _, ...rest } = obj\n\n    return rest\n  }\n\n  if (primaryKey && obj[primaryKey] && isObject(obj[primaryKey])) {\n    return {\n      ...obj,\n      [primaryKey]: omitObjectHelper(obj[primaryKey], restKeys),\n    }\n  }\n\n  return obj\n}\n\nexport function omitObject<\n  Y extends Dict,\n  M extends keyof Y = keyof Y,\n  D = any,\n>(obj: Y, keys: M[] | readonly M[]) {\n  return (keys as M[]).reduce((prev, key) => {\n    const path = (isString(key) ? key.split(\".\") : []) as M[]\n\n    return omitObjectHelper(prev, path)\n  }, obj) as unknown as D extends unknown ? Omit<Y, M> : D\n}\n\nexport function pickObject<\n  Y extends Dict,\n  M extends keyof Y = keyof Y,\n  D = any,\n>(obj: Y, keys: M[] | readonly M[], fallbackValue = \"__fallback\") {\n  return (keys as M[]).reduce((prev, key) => {\n    const path = isString(key) ? key.split(\".\") : []\n\n    if (!path.length) return prev\n\n    const value = getMemoizedObject(obj, key as string, fallbackValue)\n\n    if (value === fallbackValue) return prev\n\n    prev = merge(\n      prev,\n      path.reduceRight(\n        (prev, key) => ({ [key]: key === path.at(-1) ? value : prev }),\n        {},\n      ),\n    )\n\n    return prev\n  }, {}) as D extends unknown ? { [H in M]: Y[H] } : D\n}\n\nexport function splitObject<Y extends Dict, M extends keyof Y>(\n  obj: Y,\n  keys: M[] | readonly M[],\n) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (keys.includes(key as Y[M])) {\n      picked[key] = value\n    } else {\n      omitted[key] = value\n    }\n  }\n\n  return [picked, omitted] as [{ [P in M]: Y[P] }, Omit<Y, M>]\n}\n\nexport function filterObject<Y extends Dict, M extends Dict>(\n  obj: Y,\n  func: (key: keyof Y, value: Y[keyof Y], obj: Y) => boolean,\n): M {\n  const result: Dict = {}\n\n  Object.entries(obj).forEach(([key, value]) => {\n    const shouldPass = func(key, value, obj)\n\n    if (shouldPass) result[key] = value\n  })\n\n  return result as M\n}\n\nexport function filterUndefined<Y extends Dict>(obj: Y): Y {\n  return filterObject(obj, (_, val) => val !== null && val !== undefined)\n}\n\nexport function merge<Y extends Dict>(\n  target: any,\n  source: any,\n  mergeArray = false,\n): Y {\n  let result = Object.assign({}, target)\n\n  if (isObject(source)) {\n    if (isObject(target)) {\n      for (const [sourceKey, sourceValue] of Object.entries(source)) {\n        const targetValue: any = target[sourceKey]\n\n        if (mergeArray && isArray(sourceValue) && isArray(targetValue)) {\n          result[sourceKey] = targetValue.concat(...sourceValue)\n        } else if (\n          !isFunction(sourceValue) &&\n          isObject(sourceValue) &&\n          target.hasOwnProperty(sourceKey)\n        ) {\n          result[sourceKey] = merge(targetValue, sourceValue, mergeArray)\n        } else {\n          Object.assign(result, { [sourceKey]: sourceValue })\n        }\n      }\n    } else {\n      result = source\n    }\n  }\n\n  return result as Y\n}\n\nexport interface FlattenObjectOptions {\n  maxDepth?: number\n  omitKeys?: string[]\n  separator?: string\n  shouldProcess?: (obj: any) => boolean\n}\n\nexport function flattenObject<Y extends Dict>(\n  obj: any,\n  { maxDepth, omitKeys, separator, shouldProcess }: FlattenObjectOptions = {},\n): Y {\n  maxDepth ??= Infinity\n  omitKeys ??= []\n  separator ??= \".\"\n\n  if ((!isObject(obj) && !isArray(obj)) || !maxDepth) return obj\n\n  return Object.entries(obj).reduce<any>((result, [key, value]) => {\n    if (\n      isObject(value) &&\n      !Object.keys(value).some((key) => omitKeys.includes(key)) &&\n      (!shouldProcess || shouldProcess(value))\n    ) {\n      Object.entries(\n        flattenObject(value, {\n          maxDepth: maxDepth - 1,\n          omitKeys,\n          separator,\n          shouldProcess,\n        }),\n      ).forEach(([childKey, childValue]) => {\n        result[`${key}${separator}${childKey}`] = childValue\n      })\n    } else {\n      result[key] = value\n    }\n\n    return result\n  }, {}) as Y\n}\n\nexport function objectFromEntries<Y extends Dict>(entries: any[][]): Y {\n  return entries.reduce<any>((result, [key, value]) => {\n    result[key] = value\n\n    return result\n  }, {}) as Y\n}\n\nexport function keysFormObject<Y extends object>(obj: Y): (keyof Y)[] {\n  return Object.keys(obj) as (keyof Y)[]\n}\n\nexport function replaceObject<Y = any>(\n  objOrArray: Y,\n  callBack: (value: any) => any,\n): Y {\n  if (isArray(objOrArray)) {\n    return objOrArray.map(callBack) as Y\n  } else if (isObject(objOrArray)) {\n    return Object.entries(objOrArray).reduce<Dict>((obj, [key, value]) => {\n      obj[key] = callBack(value)\n\n      return obj\n    }, {}) as Y\n  } else {\n    return callBack(objOrArray)\n  }\n}\n\nexport function getObject(\n  obj: Dict | undefined,\n  path: number | string,\n  fallback?: any,\n  i?: number,\n) {\n  const keys = isString(path)\n    ? path.split(/\\[(.*?)\\]|\\./).filter(Boolean)\n    : [path]\n\n  for (i = 0; i < keys.length; i += 1) {\n    if (!obj) break\n\n    const key = keys[i]\n\n    obj = key ? obj[key] : undefined\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\nexport function memoizeObject(func: typeof getObject) {\n  const cache = new WeakMap()\n\n  function memoizedFunc<Y>(\n    obj: Dict,\n    path: number | string,\n    fallback?: any,\n    i?: number,\n  ): Y {\n    if (isUndefined(obj)) return func(obj, path, fallback)\n\n    if (!cache.has(obj)) cache.set(obj, new Map())\n\n    const map = cache.get(obj)\n\n    if (map.has(path)) return map.get(path)\n\n    const value = func(obj, path, fallback, i)\n\n    map.set(path, value)\n\n    return value as Y\n  }\n\n  return memoizedFunc\n}\n\nexport const getMemoizedObject = memoizeObject(getObject)\n\nexport function assignAfter(target: { [key: string]: any }, ...sources: any[]) {\n  const result: { [key: string]: unknown } = { ...target }\n\n  for (const nextSource of sources) {\n    if (nextSource == null) continue\n\n    for (const nextKey in nextSource) {\n      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) continue\n\n      if (nextKey in result) delete result[nextKey]\n\n      result[nextKey] = nextSource[nextKey]\n    }\n  }\n\n  return result\n}\n"],"mappings":"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","names":["parseToHsla","parseToRgba","isDark","hsla","rgba","parseToRgba","parseToHsla","v"]}