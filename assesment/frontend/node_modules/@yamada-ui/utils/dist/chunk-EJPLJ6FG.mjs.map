{"version":3,"sources":["../src/object.ts"],"sourcesContent":["import type { Dict } from \"./index.types\"\nimport {\n  isArray,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n} from \"./assertion\"\n\nfunction omitObjectHelper<Y extends Dict, M extends keyof Y>(\n  obj: Y,\n  path: M[] | readonly M[],\n): any {\n  if (!path.length) return obj\n\n  const [primaryKey, ...restKeys] = path\n\n  if (restKeys.length === 0 && primaryKey && primaryKey in obj) {\n    const { [primaryKey]: _, ...rest } = obj\n\n    return rest\n  }\n\n  if (primaryKey && obj[primaryKey] && isObject(obj[primaryKey])) {\n    return {\n      ...obj,\n      [primaryKey]: omitObjectHelper(obj[primaryKey], restKeys),\n    }\n  }\n\n  return obj\n}\n\nexport function omitObject<\n  Y extends Dict,\n  M extends keyof Y = keyof Y,\n  D = any,\n>(obj: Y, keys: M[] | readonly M[]) {\n  return (keys as M[]).reduce((prev, key) => {\n    const path = (isString(key) ? key.split(\".\") : []) as M[]\n\n    return omitObjectHelper(prev, path)\n  }, obj) as unknown as D extends unknown ? Omit<Y, M> : D\n}\n\nexport function pickObject<\n  Y extends Dict,\n  M extends keyof Y = keyof Y,\n  D = any,\n>(obj: Y, keys: M[] | readonly M[], fallbackValue = \"__fallback\") {\n  return (keys as M[]).reduce((prev, key) => {\n    const path = isString(key) ? key.split(\".\") : []\n\n    if (!path.length) return prev\n\n    const value = getMemoizedObject(obj, key as string, fallbackValue)\n\n    if (value === fallbackValue) return prev\n\n    prev = merge(\n      prev,\n      path.reduceRight(\n        (prev, key) => ({ [key]: key === path.at(-1) ? value : prev }),\n        {},\n      ),\n    )\n\n    return prev\n  }, {}) as D extends unknown ? { [H in M]: Y[H] } : D\n}\n\nexport function splitObject<Y extends Dict, M extends keyof Y>(\n  obj: Y,\n  keys: M[] | readonly M[],\n) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (keys.includes(key as Y[M])) {\n      picked[key] = value\n    } else {\n      omitted[key] = value\n    }\n  }\n\n  return [picked, omitted] as [{ [P in M]: Y[P] }, Omit<Y, M>]\n}\n\nexport function filterObject<Y extends Dict, M extends Dict>(\n  obj: Y,\n  func: (key: keyof Y, value: Y[keyof Y], obj: Y) => boolean,\n): M {\n  const result: Dict = {}\n\n  Object.entries(obj).forEach(([key, value]) => {\n    const shouldPass = func(key, value, obj)\n\n    if (shouldPass) result[key] = value\n  })\n\n  return result as M\n}\n\nexport function filterUndefined<Y extends Dict>(obj: Y): Y {\n  return filterObject(obj, (_, val) => val !== null && val !== undefined)\n}\n\nexport function merge<Y extends Dict>(\n  target: any,\n  source: any,\n  mergeArray = false,\n): Y {\n  let result = Object.assign({}, target)\n\n  if (isObject(source)) {\n    if (isObject(target)) {\n      for (const [sourceKey, sourceValue] of Object.entries(source)) {\n        const targetValue: any = target[sourceKey]\n\n        if (mergeArray && isArray(sourceValue) && isArray(targetValue)) {\n          result[sourceKey] = targetValue.concat(...sourceValue)\n        } else if (\n          !isFunction(sourceValue) &&\n          isObject(sourceValue) &&\n          target.hasOwnProperty(sourceKey)\n        ) {\n          result[sourceKey] = merge(targetValue, sourceValue, mergeArray)\n        } else {\n          Object.assign(result, { [sourceKey]: sourceValue })\n        }\n      }\n    } else {\n      result = source\n    }\n  }\n\n  return result as Y\n}\n\nexport interface FlattenObjectOptions {\n  maxDepth?: number\n  omitKeys?: string[]\n  separator?: string\n  shouldProcess?: (obj: any) => boolean\n}\n\nexport function flattenObject<Y extends Dict>(\n  obj: any,\n  { maxDepth, omitKeys, separator, shouldProcess }: FlattenObjectOptions = {},\n): Y {\n  maxDepth ??= Infinity\n  omitKeys ??= []\n  separator ??= \".\"\n\n  if ((!isObject(obj) && !isArray(obj)) || !maxDepth) return obj\n\n  return Object.entries(obj).reduce<any>((result, [key, value]) => {\n    if (\n      isObject(value) &&\n      !Object.keys(value).some((key) => omitKeys.includes(key)) &&\n      (!shouldProcess || shouldProcess(value))\n    ) {\n      Object.entries(\n        flattenObject(value, {\n          maxDepth: maxDepth - 1,\n          omitKeys,\n          separator,\n          shouldProcess,\n        }),\n      ).forEach(([childKey, childValue]) => {\n        result[`${key}${separator}${childKey}`] = childValue\n      })\n    } else {\n      result[key] = value\n    }\n\n    return result\n  }, {}) as Y\n}\n\nexport function objectFromEntries<Y extends Dict>(entries: any[][]): Y {\n  return entries.reduce<any>((result, [key, value]) => {\n    result[key] = value\n\n    return result\n  }, {}) as Y\n}\n\nexport function keysFormObject<Y extends object>(obj: Y): (keyof Y)[] {\n  return Object.keys(obj) as (keyof Y)[]\n}\n\nexport function replaceObject<Y = any>(\n  objOrArray: Y,\n  callBack: (value: any) => any,\n): Y {\n  if (isArray(objOrArray)) {\n    return objOrArray.map(callBack) as Y\n  } else if (isObject(objOrArray)) {\n    return Object.entries(objOrArray).reduce<Dict>((obj, [key, value]) => {\n      obj[key] = callBack(value)\n\n      return obj\n    }, {}) as Y\n  } else {\n    return callBack(objOrArray)\n  }\n}\n\nexport function getObject(\n  obj: Dict | undefined,\n  path: number | string,\n  fallback?: any,\n  i?: number,\n) {\n  const keys = isString(path)\n    ? path.split(/\\[(.*?)\\]|\\./).filter(Boolean)\n    : [path]\n\n  for (i = 0; i < keys.length; i += 1) {\n    if (!obj) break\n\n    const key = keys[i]\n\n    obj = key ? obj[key] : undefined\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\nexport function memoizeObject(func: typeof getObject) {\n  const cache = new WeakMap()\n\n  function memoizedFunc<Y>(\n    obj: Dict,\n    path: number | string,\n    fallback?: any,\n    i?: number,\n  ): Y {\n    if (isUndefined(obj)) return func(obj, path, fallback)\n\n    if (!cache.has(obj)) cache.set(obj, new Map())\n\n    const map = cache.get(obj)\n\n    if (map.has(path)) return map.get(path)\n\n    const value = func(obj, path, fallback, i)\n\n    map.set(path, value)\n\n    return value as Y\n  }\n\n  return memoizedFunc\n}\n\nexport const getMemoizedObject = memoizeObject(getObject)\n\nexport function assignAfter(target: { [key: string]: any }, ...sources: any[]) {\n  const result: { [key: string]: unknown } = { ...target }\n\n  for (const nextSource of sources) {\n    if (nextSource == null) continue\n\n    for (const nextKey in nextSource) {\n      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) continue\n\n      if (nextKey in result) delete result[nextKey]\n\n      result[nextKey] = nextSource[nextKey]\n    }\n  }\n\n  return result\n}\n"],"mappings":";;;;;;;;;AASA,SAAS,iBACP,KACA,MACK;AACL,MAAI,CAAC,KAAK,OAAQ,QAAO;AAEzB,QAAM,CAAC,YAAY,GAAG,QAAQ,IAAI;AAElC,MAAI,SAAS,WAAW,KAAK,cAAc,cAAc,KAAK;AAC5D,UAAM,EAAE,CAAC,UAAU,GAAG,GAAG,GAAG,KAAK,IAAI;AAErC,WAAO;AAAA,EACT;AAEA,MAAI,cAAc,IAAI,UAAU,KAAK,SAAS,IAAI,UAAU,CAAC,GAAG;AAC9D,WAAO;AAAA,MACL,GAAG;AAAA,MACH,CAAC,UAAU,GAAG,iBAAiB,IAAI,UAAU,GAAG,QAAQ;AAAA,IAC1D;AAAA,EACF;AAEA,SAAO;AACT;AAEO,SAAS,WAId,KAAQ,MAA0B;AAClC,SAAQ,KAAa,OAAO,CAAC,MAAM,QAAQ;AACzC,UAAM,OAAQ,SAAS,GAAG,IAAI,IAAI,MAAM,GAAG,IAAI,CAAC;AAEhD,WAAO,iBAAiB,MAAM,IAAI;AAAA,EACpC,GAAG,GAAG;AACR;AAEO,SAAS,WAId,KAAQ,MAA0B,gBAAgB,cAAc;AAChE,SAAQ,KAAa,OAAO,CAAC,MAAM,QAAQ;AACzC,UAAM,OAAO,SAAS,GAAG,IAAI,IAAI,MAAM,GAAG,IAAI,CAAC;AAE/C,QAAI,CAAC,KAAK,OAAQ,QAAO;AAEzB,UAAM,QAAQ,kBAAkB,KAAK,KAAe,aAAa;AAEjE,QAAI,UAAU,cAAe,QAAO;AAEpC,WAAO;AAAA,MACL;AAAA,MACA,KAAK;AAAA,QACH,CAACA,OAAMC,UAAS,EAAE,CAACA,IAAG,GAAGA,SAAQ,KAAK,GAAG,EAAE,IAAI,QAAQD,MAAK;AAAA,QAC5D,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP;AAEO,SAAS,YACd,KACA,MACA;AACA,QAAM,SAAe,CAAC;AACtB,QAAM,UAAgB,CAAC;AAEvB,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,GAAG,GAAG;AAC9C,QAAI,KAAK,SAAS,GAAW,GAAG;AAC9B,aAAO,GAAG,IAAI;AAAA,IAChB,OAAO;AACL,cAAQ,GAAG,IAAI;AAAA,IACjB;AAAA,EACF;AAEA,SAAO,CAAC,QAAQ,OAAO;AACzB;AAEO,SAAS,aACd,KACA,MACG;AACH,QAAM,SAAe,CAAC;AAEtB,SAAO,QAAQ,GAAG,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAC5C,UAAM,aAAa,KAAK,KAAK,OAAO,GAAG;AAEvC,QAAI,WAAY,QAAO,GAAG,IAAI;AAAA,EAChC,CAAC;AAED,SAAO;AACT;AAEO,SAAS,gBAAgC,KAAW;AACzD,SAAO,aAAa,KAAK,CAAC,GAAG,QAAQ,QAAQ,QAAQ,QAAQ,MAAS;AACxE;AAEO,SAAS,MACd,QACA,QACA,aAAa,OACV;AACH,MAAI,SAAS,OAAO,OAAO,CAAC,GAAG,MAAM;AAErC,MAAI,SAAS,MAAM,GAAG;AACpB,QAAI,SAAS,MAAM,GAAG;AACpB,iBAAW,CAAC,WAAW,WAAW,KAAK,OAAO,QAAQ,MAAM,GAAG;AAC7D,cAAM,cAAmB,OAAO,SAAS;AAEzC,YAAI,cAAc,QAAQ,WAAW,KAAK,QAAQ,WAAW,GAAG;AAC9D,iBAAO,SAAS,IAAI,YAAY,OAAO,GAAG,WAAW;AAAA,QACvD,WACE,CAAC,WAAW,WAAW,KACvB,SAAS,WAAW,KACpB,OAAO,eAAe,SAAS,GAC/B;AACA,iBAAO,SAAS,IAAI,MAAM,aAAa,aAAa,UAAU;AAAA,QAChE,OAAO;AACL,iBAAO,OAAO,QAAQ,EAAE,CAAC,SAAS,GAAG,YAAY,CAAC;AAAA,QACpD;AAAA,MACF;AAAA,IACF,OAAO;AACL,eAAS;AAAA,IACX;AAAA,EACF;AAEA,SAAO;AACT;AASO,SAAS,cACd,KACA,EAAE,UAAU,UAAU,WAAW,cAAc,IAA0B,CAAC,GACvE;AACH,2CAAa;AACb,2CAAa,CAAC;AACd,8CAAc;AAEd,MAAK,CAAC,SAAS,GAAG,KAAK,CAAC,QAAQ,GAAG,KAAM,CAAC,SAAU,QAAO;AAE3D,SAAO,OAAO,QAAQ,GAAG,EAAE,OAAY,CAAC,QAAQ,CAAC,KAAK,KAAK,MAAM;AAC/D,QACE,SAAS,KAAK,KACd,CAAC,OAAO,KAAK,KAAK,EAAE,KAAK,CAACC,SAAQ,SAAS,SAASA,IAAG,CAAC,MACvD,CAAC,iBAAiB,cAAc,KAAK,IACtC;AACA,aAAO;AAAA,QACL,cAAc,OAAO;AAAA,UACnB,UAAU,WAAW;AAAA,UACrB;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH,EAAE,QAAQ,CAAC,CAAC,UAAU,UAAU,MAAM;AACpC,eAAO,GAAG,GAAG,GAAG,SAAS,GAAG,QAAQ,EAAE,IAAI;AAAA,MAC5C,CAAC;AAAA,IACH,OAAO;AACL,aAAO,GAAG,IAAI;AAAA,IAChB;AAEA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP;AAEO,SAAS,kBAAkC,SAAqB;AACrE,SAAO,QAAQ,OAAY,CAAC,QAAQ,CAAC,KAAK,KAAK,MAAM;AACnD,WAAO,GAAG,IAAI;AAEd,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP;AAEO,SAAS,eAAiC,KAAqB;AACpE,SAAO,OAAO,KAAK,GAAG;AACxB;AAEO,SAAS,cACd,YACA,UACG;AACH,MAAI,QAAQ,UAAU,GAAG;AACvB,WAAO,WAAW,IAAI,QAAQ;AAAA,EAChC,WAAW,SAAS,UAAU,GAAG;AAC/B,WAAO,OAAO,QAAQ,UAAU,EAAE,OAAa,CAAC,KAAK,CAAC,KAAK,KAAK,MAAM;AACpE,UAAI,GAAG,IAAI,SAAS,KAAK;AAEzB,aAAO;AAAA,IACT,GAAG,CAAC,CAAC;AAAA,EACP,OAAO;AACL,WAAO,SAAS,UAAU;AAAA,EAC5B;AACF;AAEO,SAAS,UACd,KACA,MACA,UACA,GACA;AACA,QAAM,OAAO,SAAS,IAAI,IACtB,KAAK,MAAM,cAAc,EAAE,OAAO,OAAO,IACzC,CAAC,IAAI;AAET,OAAK,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GAAG;AACnC,QAAI,CAAC,IAAK;AAEV,UAAM,MAAM,KAAK,CAAC;AAElB,UAAM,MAAM,IAAI,GAAG,IAAI;AAAA,EACzB;AAEA,SAAO,QAAQ,SAAY,WAAW;AACxC;AAEO,SAAS,cAAc,MAAwB;AACpD,QAAM,QAAQ,oBAAI,QAAQ;AAE1B,WAAS,aACP,KACA,MACA,UACA,GACG;AACH,QAAI,YAAY,GAAG,EAAG,QAAO,KAAK,KAAK,MAAM,QAAQ;AAErD,QAAI,CAAC,MAAM,IAAI,GAAG,EAAG,OAAM,IAAI,KAAK,oBAAI,IAAI,CAAC;AAE7C,UAAM,MAAM,MAAM,IAAI,GAAG;AAEzB,QAAI,IAAI,IAAI,IAAI,EAAG,QAAO,IAAI,IAAI,IAAI;AAEtC,UAAM,QAAQ,KAAK,KAAK,MAAM,UAAU,CAAC;AAEzC,QAAI,IAAI,MAAM,KAAK;AAEnB,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,IAAM,oBAAoB,cAAc,SAAS;AAEjD,SAAS,YAAY,WAAmC,SAAgB;AAC7E,QAAM,SAAqC,EAAE,GAAG,OAAO;AAEvD,aAAW,cAAc,SAAS;AAChC,QAAI,cAAc,KAAM;AAExB,eAAW,WAAW,YAAY;AAChC,UAAI,CAAC,OAAO,UAAU,eAAe,KAAK,YAAY,OAAO,EAAG;AAEhE,UAAI,WAAW,OAAQ,QAAO,OAAO,OAAO;AAE5C,aAAO,OAAO,IAAI,WAAW,OAAO;AAAA,IACtC;AAAA,EACF;AAEA,SAAO;AACT;","names":["prev","key"]}