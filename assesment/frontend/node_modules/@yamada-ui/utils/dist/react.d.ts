import * as React from 'react';

type MaybeRenderProp<Y> = ((props: Y) => React.ReactNode) | React.ReactNode;
type CreateContextReturn<Y> = [React.Provider<Y>, () => Y, React.Context<Y>];
declare function createContext<Y = any>(options: {
    name?: string;
    defaultValue?: Y;
    errorMessage?: string;
    strict?: true;
}): CreateContextReturn<Y>;
declare function createContext<Y = any>(options: {
    name?: string;
    defaultValue?: Y;
    errorMessage?: string;
    strict?: false;
}): CreateContextReturn<undefined | Y>;
declare const useSafeLayoutEffect: typeof React.useLayoutEffect;
declare function useUnmountEffect(callback: () => void): void;
interface UseIsMountedProps {
    delay?: number;
    rerender?: boolean;
}
declare function useIsMounted({ delay, rerender, }?: UseIsMountedProps): [() => boolean, boolean];
type UseIsMountedReturn = ReturnType<typeof useIsMounted>;
declare function getValidChildren(children: React.ReactNode): React.ReactElement[];
declare function isValidElement(child: any): child is React.ReactNode;
declare function isSomeElement(child: any, type: any): boolean;
declare function findChild(children: React.ReactElement[], ...types: (React.JSXElementConstructor<any> | string)[]): React.ReactElement | undefined;
declare function findChildren(children: React.ReactElement[], ...types: (React.JSXElementConstructor<any> | string)[]): [React.ReactElement | undefined, ...React.ReactElement[]];
declare function includesChildren(children: React.ReactElement[], ...types: (React.JSXElementConstructor<any> | string)[]): boolean;
declare function omitChildren(children: React.ReactElement[], ...types: (React.JSXElementConstructor<any> | string)[]): React.ReactElement[];
declare function pickChildren(children: React.ReactElement[], ...types: (React.JSXElementConstructor<any> | string)[]): React.ReactElement[];
declare function cx(...classNames: (string | undefined)[]): string;
type ReactRef<T> = React.LegacyRef<T> | React.MutableRefObject<T> | React.Ref<T>;
declare function isRefObject(val: any): val is {
    current: any;
};
declare function assignRef<T = any>(ref: ReactRef<T> | undefined, value: T): void;
declare function mergeRefs<T = any>(...refs: (null | ReactRef<T> | undefined)[]): (node: null | T) => void;
declare function useMergeRefs<T = any>(...refs: (ReactRef<T> | undefined)[]): (node: T | null) => void;
declare function useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined, deps?: React.DependencyList): T;
/**
 * `useUpdateEffect` is a custom hook that skips side effects on the initial render, and only runs them when the dependency array changes.
 *
 * @see Docs https://yamada-ui.com/hooks/use-update-effect
 */
declare function useUpdateEffect(callback: React.EffectCallback, deps: React.DependencyList): void;
type FunctionReturningPromise = (...args: any[]) => Promise<any>;
/**
 * `useAsync` is a custom hook that executes an asynchronous function and tracks its state.
 *
 * @see Docs https://yamada-ui.com/hooks/use-async
 */
declare function useAsync<T extends FunctionReturningPromise>(func: T, deps?: React.DependencyList): StateFromFunctionReturningPromise<T>;
type AsyncState<T> = {
    error: Error;
    loading: false;
    value?: undefined;
} | {
    loading: boolean;
    error?: undefined;
    value?: undefined;
} | {
    loading: false;
    value: T;
    error?: undefined;
} | {
    loading: true;
    error?: Error | undefined;
    value?: T;
};
type PromiseType<P extends Promise<any>> = P extends Promise<infer T> ? T : never;
type StateFromFunctionReturningPromise<T extends FunctionReturningPromise> = AsyncState<PromiseType<ReturnType<T>>>;
type AsyncFnReturn<T extends FunctionReturningPromise = FunctionReturningPromise> = [StateFromFunctionReturningPromise<T>, T];
declare function useAsyncFunc<T extends FunctionReturningPromise>(func: T, deps?: React.DependencyList, initialState?: StateFromFunctionReturningPromise<T>): AsyncFnReturn<T>;
type AsyncStateRetry<T> = {
    retry(): void;
} & AsyncState<T>;
declare function useAsyncRetry<T>(func: () => Promise<T>, deps?: React.DependencyList): {
    retry: () => void;
    error: Error;
    loading: false;
    value?: undefined;
} | {
    retry: () => void;
    loading: boolean;
    error?: undefined;
    value?: undefined;
} | {
    retry: () => void;
    loading: false;
    value: T;
    error?: undefined;
} | {
    retry: () => void;
    loading: true;
    error?: Error | undefined;
    value?: T | undefined;
};
declare function createId(prefix: string): string;

export { type AsyncFnReturn, type AsyncState, type AsyncStateRetry, type FunctionReturningPromise, type MaybeRenderProp, type PromiseType, type UseIsMountedProps, type UseIsMountedReturn, assignRef, createContext, createId, cx, findChild, findChildren, getValidChildren, includesChildren, isRefObject, isSomeElement, isValidElement, mergeRefs, omitChildren, pickChildren, useAsync, useAsyncFunc, useAsyncRetry, useCallbackRef, useIsMounted, useMergeRefs, useSafeLayoutEffect, useUnmountEffect, useUpdateEffect };
