type Primitive = bigint | boolean | null | number | string | symbol | undefined;
type PathImpl<Y extends number | string | symbol, M> = Y extends number | string ? M extends Primitive ? `${Y}` : `${Y}.${Path<M>}` : ``;
type Path<Y> = {
    [M in keyof Y]-?: PathImpl<M, Y[M]>;
}[keyof Y];
interface Dict<Y = any> {
    [key: string]: Y;
}
interface ObjectLiteral {
}
type StringLiteral = {} & string;
type Replace<Y extends string, M extends string, D extends string, H extends string = ""> = Y extends `${infer T}${M}${infer R}` ? Replace<R, M, D, `${H}${T}${D}`> : `${H}${Y}`;
type Union<Y> = StringLiteral | Y;
type Length<T extends any[]> = T["length"];
type Merge<Y, M> = M & Omit<Y, keyof M>;

export type { Dict, Length, Merge, ObjectLiteral, Path, Primitive, Replace, StringLiteral, Union };
